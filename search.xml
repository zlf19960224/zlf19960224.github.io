<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>HTTP-笔记</title>
      <link href="/2019/03/14/HTTP/"/>
      <url>/2019/03/14/HTTP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content-Security-Policy"></a>Content-Security-Policy</h4><ol><li>限制资源获取<ol><li><code>default-src</code></li></ol></li><li>报告资源获取越权</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不需要预请求</p><ul><li>GET</li><li>POST</li><li>HEAD</li></ul></blockquote><blockquote><p>允许<code>content-type</code></p><p><code>text/plain</code></p><p><code>multipart/form-data</code></p><p><code>application/x-www-form-urlencoded</code></p></blockquote><h4 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h4><p><code>Access-Control-Allow-Origins:*</code></p><p><code>Access-Control-Allow-Headers:X-Test-Cors</code></p><p><code>Access-Control-Allow-Methods:&#39;&#39;PUT,POST...&#39;</code></p><h4 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h4><blockquote><ul><li>public</li><li>private</li><li>no-cache</li><li>max-age</li></ul></blockquote><p><code>no-store</code>—&gt;本地和代理服务器都不能缓存,忽略所有缓存</p><p><code>no-transform</code>—&gt;不允许更改本地和代理服务器</p><p>####<code>last-modefied&amp;Etag</code></p><h4 id="cookie中的domain"><a href="#cookie中的domain" class="headerlink" title="cookie中的domain"></a><code>cookie中的domain</code></h4><blockquote><p>设置同一父域名，子域名不同情况下的cookie能共用</p></blockquote><h4 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h4><ol><li>tcp有连接，udp无连接</li><li>tcp稳定，udp不稳定，可能丢包</li><li>tcp用于http，udp用于实时的视频、通讯等</li></ol>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack study</title>
      <link href="/2019/03/14/webpack-study/"/>
      <url>/2019/03/14/webpack-study/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HMR局部更新"><a href="#HMR局部更新" class="headerlink" title="HMR局部更新"></a>HMR局部更新</h2><p><code>hot，hotOnly(刷新页面)</code></p><p><code>plugins：{new webpack.HotMouduleReplacementPlugin();}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(module.hot)&#123;</span><br><span class="line">    module.hot.accept(&apos;./xxxx.js&apos;,()=&gt;&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules:[&#123;</span><br><span class="line">    test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">    options:&#123;</span><br><span class="line">        presets:[[<span class="string">"@babel/present-env"</span>],&#123;<span class="attr">useBuiltIns</span>:<span class="string">'usage'</span>&#125;]<span class="comment">//es6语法转es5</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure><h2 id="配置React代码的打包"><a href="#配置React代码的打包" class="headerlink" title="配置React代码的打包"></a>配置React代码的打包</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options:&#123;</span><br><span class="line">        presets:[[<span class="string">"@babel/present-env"</span>,&#123;<span class="attr">useBuiltIns</span>:<span class="string">'usage'</span>&#125;],<span class="string">"@babel/preset-react"</span>]<span class="comment">//es6语法转es5</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>preset</code>从右往左，从下往上</p><h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h2><blockquote><ol><li><p>只支持ESmodule属于静态引入，commonJs动态引入；</p><p><code>optimization:{</code></p><p>​    <code>usedExports:true//production不需要写此段代码</code></p><p><code>}</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    //package.json</span><br><span class="line">&gt;    &#123;sideEffects:["@babel/polyfill","*.css"]&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote></blockquote><h2 id="code-splitting"><a href="#code-splitting" class="headerlink" title="code splitting"></a>code splitting</h2><blockquote><p>代码拆分，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:&apos;all&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="chunk是什么"><a href="#chunk是什么" class="headerlink" title="chunk是什么"></a>chunk是什么</h2><blockquote><p>生成的每一个文件都是一个chunk</p></blockquote><h2 id="prefetch-preload"><a href="#prefetch-preload" class="headerlink" title="prefetch,preload"></a>prefetch,preload</h2><p><code>magic注释</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽量使用prefetch，/*webpackPrefetch: true*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现超出js范围的bigInt的两个数字相加</title>
      <link href="/2019/03/14/add-bigInt/"/>
      <url>/2019/03/14/add-bigInt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>####实现超出js范围的bigInt的两个数字相加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aArr = <span class="built_in">Array</span>.prototype.slice.call(a.toString());</span><br><span class="line">    <span class="keyword">var</span> bArr = <span class="built_in">Array</span>.prototype.slice.call(b.toString());</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> inc = [];</span><br><span class="line">    <span class="keyword">var</span> length = aArr.length &gt; bArr.length ? aArr.length : bArr.length;</span><br><span class="line">    <span class="comment">//初始化所有为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!aArr[j]) &#123;</span><br><span class="line">            aArr.unshift(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bArr[j]) &#123;</span><br><span class="line">            bArr.unshift(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    aArr = aArr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">parseInt</span>(item));</span><br><span class="line">    bArr = bArr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">parseInt</span>(item));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i === j) &#123;</span><br><span class="line">                <span class="keyword">var</span> result = aArr[i] + bArr[j];</span><br><span class="line">                inc.unshift(result);</span><br><span class="line">                arr = resolution(inc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolution</span>(<span class="params">inc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = inc.length - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inc[k] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                inc[k] -= <span class="number">10</span>;</span><br><span class="line">                inc[k - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(inc.join(<span class="string">""</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">999999</span>, <span class="number">999</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题6</title>
      <link href="/2019/03/11/answer6/"/>
      <url>/2019/03/11/answer6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h2><ul><li>即时运行错误<ul><li>window.onError</li><li>try..catch..</li></ul></li><li>资源加载错误<ul><li>object.onError</li><li>performance.getentries</li><li>error捕获<ul><li>addEventListener(()=&gt;{},true)        </li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跨域js错误</span></span><br><span class="line"><span class="comment">//1、script设置crossOrigin</span></span><br><span class="line"><span class="comment">//2、服务器设置Acess-control-allow-origin</span></span><br></pre></td></tr></table></figure><blockquote><p>上报错误的两种</p><ol><li>Ajax</li><li>new Image（）<ul><li><code>（new Image()).src=&quot;http://www.baidu.com?sssstsa=2&amp;ssas=1&quot;</code></li></ul></li></ol></blockquote><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li>压缩文件合并代码，减少http</li><li>异步加载script<ul><li>document.createElement(“script”)</li><li>defer<ul><li>html解析完后异步加载script</li></ul></li><li>async<ul><li>加载完毕后异步加载script</li></ul></li></ul></li><li>使用CDN</li><li>使用preDNS<ul><li>meta强制a标签中做DNS预解析</li><li><code>&lt;link rel=&quot;dns-prefetch&quot; content=&quot;on&quot;&gt;</code></li></ul></li><li>使用浏览器缓存<ul><li>强制缓存<ul><li>Expires（设置具体时间，以客户端为准）</li><li>cache-control(设置时间长度，以客户端为准)</li></ul></li><li>协商缓存<ul><li>last-modefied</li><li>If-modefied-since</li><li>Etag(hash)</li><li>If-None-Match</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端面试题5</title>
      <link href="/2019/03/10/answer5/"/>
      <url>/2019/03/10/answer5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><blockquote><ol><li>background/border</li><li>z-index:0-</li><li>块级元素</li><li>浮动元素</li><li>行内元素</li><li>z-index:0/auto</li><li>z-index:0+</li></ol><p><code>ps</code>:从底到高</p></blockquote></li></ul><h5 id="web-Worker"><a href="#web-Worker" class="headerlink" title="web Worker"></a>web Worker</h5><blockquote><p>​    现代浏览器为<code>JavaScript</code>创造的 <strong>多线程环境</strong>。可以新建并将部分任务分配到worker线程并行运行，两个线程可独立运行，互不干扰，可通过自带的<strong>消息机制</strong>互相通信</p></blockquote><p><strong>限制:</strong></p><ul><li>同源限制</li><li>无法使用 <code>document</code> / <code>window</code> / <code>alert</code> / <code>confirm</code></li><li>无法加载本地资源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建 worker</span><br><span class="line">const worker = new Worker(&apos;work.js&apos;);</span><br><span class="line"></span><br><span class="line">// 向主进程推送消息</span><br><span class="line">worker.postMessage(&apos;Hello World&apos;);</span><br><span class="line"></span><br><span class="line">// 监听主进程来的消息</span><br><span class="line">worker.onmessage = function (event) &#123;</span><br><span class="line">  console.log(&apos;Received message &apos; + event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="http"><a href="#http" class="headerlink" title="http"></a>http</h5><p>2.0:</p><ul><li>多路复用</li><li>二进制分帧层: 应用层和传输层之间</li><li>首部压缩</li><li>服务端推送</li></ul><p>https: 较为安全的网络传输协议</p><ul><li>证书(公钥)</li><li>SSL 加密</li><li>端口 443</li></ul><p>TCP:</p><ul><li>三次握手</li><li>四次挥手</li><li>滑动窗口: 流量控制</li><li>拥塞处理 <ul><li>慢开始</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul></li></ul><p>缓存策略: 可分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong></p><ul><li>Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，<strong>Cache-Control的 max-age 优先级高于 Expires</strong></li><li>当缓存已经过期时，使用协商缓存<ul><li>唯一标识方案: Etag(response 携带) &amp; If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，</li><li>最后一次修改时间: Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的Last-Modified) <ul><li>如果一致，则直接返回 304 通知浏览器使用缓存</li><li>如不一致，则服务端返回新的资源</li></ul></li></ul></li><li>Last-Modified 缺点：<ul><li>周期性修改，但内容未变时，会导致缓存失效</li><li>最小粒度只到 s， s 以内的改动无法检测到</li></ul></li><li>Etag 的优先级高于 Last-Modified</li></ul><h5 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h5><p>将 H5 接入 App 中通常有两种方式：</p><p>(1) <strong>在线H5</strong>，这是最常见的一种方式。我们只需要将H5代码部署到服务器上，只要把对应的 URL地址 给到客户端，用 WebView 打开该URL，即可嵌入。该方式的好处在于:</p><ul><li>独立性强，有非常独立的开发/调试/更新/上线能力；</li><li>资源放在服务器上，完全不会影响客户端的包体积；</li><li>接入成本很低，完全的热更新机制。</li></ul><p>但相对的，这种方式也有对应的缺点:</p><ul><li>完全的网络依赖，在离线的情况下无法打开页面；</li><li>首屏加载速度依赖于网络，网络较慢时，首屏加载也较慢；</li></ul><p>通常，这种方式更适用在一些比较轻量级的页面上，例如一些帮助页、提示页、使用攻略等页面。这些页面的特点是<strong>功能性不强，不太需要复杂的功能协议，且不需要离线使用</strong>。在一些第三方页面接入上，也会使用这种方式，例如我们的页面调用微信JS-SDK。</p><p>(2) <strong>内置包H5</strong>，这是一种本地化的嵌入方式，我们需要将代码进行打包后下发到客户端，并由客户端直接解压到本地储存中。通常我们运用在一些比较大和比较重要的模块上。其优点是:</p><ul><li>由于其本地化，首屏加载速度快，用户体验更为接近原生；</li><li>可以不依赖网络，离线运行；</li></ul><p>但同时，它的劣势也十分明显:</p><ul><li>开发流程/更新机制复杂化，需要客户端，甚至服务端的共同协作；</li><li>会相应的增加 App 包体积；</li></ul><p>这两种接入方式均有自己的优缺点，应该根据不同场景进行选择。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现继承第一种方法，借助构造函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但是不继承父类原型对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent1.call(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现继承第二种方法，借助原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺点：原型链中的原型对象是公用的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'child2'</span></span><br><span class="line">&#125;</span><br><span class="line">Child2.prototype=<span class="keyword">new</span> Parent2()</span><br><span class="line"><span class="comment">//实现继承第三种方法，借助组合方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'parent3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Parent3.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.type=<span class="string">'child3'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span><span class="comment">//Child3.prototype=new Parent3()//缺点：父级构造函数执行了两次</span></span><br><span class="line"><span class="number">2.</span><span class="comment">//Child3.prototype=Parent3.prototype;//缺点：子类原型对象的constructor为父类构造函数</span></span><br><span class="line"><span class="number">3.</span><span class="comment">//child3.prototype=Object.create(Parent3.prototype);child3.prototype.constructor=Child3</span></span><br></pre></td></tr></table></figure><h5 id="前后端通信"><a href="#前后端通信" class="headerlink" title="前后端通信"></a>前后端通信</h5><ul><li>ajax</li><li>cors</li><li>websocket</li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol><li><p>var s =Object.create(person)后面跟的是原型。为啥平时写普通对象也可以？</p><p>解：</p><ul><li>一个对象的<code>prototype</code>是父对象的<code>__proto__</code></li><li>一个构造函数的<code>prototype</code>等于原型</li><li>原型为对象</li></ul><p>因此，一个普通对象person是这个普通对象person的构造函数的<code>prototype</code></p><p>object.create将这个普通对象person作为s对象的<code>prototype</code></p><p>代码如下</p><p>假设：<strong>person的constructor是function  M(){}</strong></p><p><code>s.prototype=person;等价于s.prototype=M.__proto__</code></p><p>印证：s.prototype.constructor=M</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题4</title>
      <link href="/2019/03/04/answer4/"/>
      <url>/2019/03/04/answer4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h6 id="beforeCreate-调用的时候，是获取不到-props-或者-data-中的数据的，因为这些数据的初始化都在-initState-中。"><a href="#beforeCreate-调用的时候，是获取不到-props-或者-data-中的数据的，因为这些数据的初始化都在-initState-中。" class="headerlink" title="beforeCreate 调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。"></a><code>beforeCreate</code> 调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</h6><h5 id="数据更新时会调用的钩子函数"><a href="#数据更新时会调用的钩子函数" class="headerlink" title="数据更新时会调用的钩子函数"></a>数据更新时会调用的钩子函数</h5><blockquote><ul><li><code>beforeUpdate</code></li><li><code>updated</code></li><li>activated         ——–keep-alive独有</li><li>deactivated    ——–keep-alive独有</li></ul></blockquote><p><code>VUE</code>中修改<code>data</code>里的数据时经历了哪些过程：(自己语言)</p><ol><li><code>beforeUpdate</code></li><li><code>updated</code></li></ol><h3 id="获得浏览器宽高的方式"><a href="#获得浏览器宽高的方式" class="headerlink" title="获得浏览器宽高的方式"></a>获得浏览器宽高的方式</h3><p><code>document.body.scrollTop/document.body.scrollLeft</code>浏览器滚动条整个的高/宽</p><p><code>document.body.offsetHeight/document.body.offsetWidth</code>浏览器的可见宽/高</p><h5 id="立即执行函数的目的"><a href="#立即执行函数的目的" class="headerlink" title="立即执行函数的目的"></a>立即执行函数的目的</h5><blockquote><p>​    不破坏污染全局的命名空间</p></blockquote><h5 id="不稳定的排序："><a href="#不稳定的排序：" class="headerlink" title="不稳定的排序："></a>不稳定的排序：</h5><blockquote><p>选(1)希(1)快(n^2)堆(1)</p></blockquote><h5 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h5><blockquote><p>冒（1）插（1）归（n）计（k）桶（n+k）基（n+k）</p></blockquote><h5 id="XSS-CSRF"><a href="#XSS-CSRF" class="headerlink" title="XSS,CSRF"></a>XSS,CSRF</h5><blockquote><p><code>XSS</code>指嵌入script代码（禁止访问<code>js</code>带有<code>httpOnly</code>属性的cookie,转义<code>&lt;&gt;</code>）</p><p><code>CSRF</code>伪造请求（token验证,验证码、<code>http Referer</code>）</p></blockquote><h5 id="es6模块amd-cmd-commonJs"><a href="#es6模块amd-cmd-commonJs" class="headerlink" title="es6模块amd,cmd,commonJs"></a><code>es6</code>模块<code>amd,cmd,commonJs</code></h5><ol><li><code>commonJs</code>同步加载模块，不适合浏览器使用，可能会造成浏览器阻塞</li><li><code>AMD</code>异步加载模块</li><li><code>es6</code>一个js就是一个模块，模块内部变量外部不能访问，只能export导出；</li></ol><h5 id="前端路由与后端路由的区别"><a href="#前端路由与后端路由的区别" class="headerlink" title="前端路由与后端路由的区别"></a>前端路由与后端路由的区别</h5><ol><li>后端路由，根据<code>url</code>对应刷新页面</li><li>前端路由，根据<code>url</code>对应刷新<code>dom</code></li></ol><p>#####清除浮动的方式有</p><ol><li><code>.clearfix</code></li><li><code>clear:both</code></li><li><code>overflow:hidden</code></li></ol><p><code>ps</code>：<code>display:table</code>是避免外边距margin重叠导致的margin塌陷</p><h5 id="块级元素水平垂直居中"><a href="#块级元素水平垂直居中" class="headerlink" title="块级元素水平垂直居中"></a>块级元素水平垂直居中</h5><ol><li><code>flex-----{diplay:flex;}{just-content:center;align-item:center;}</code></li><li><code>line-height</code></li><li><code>margin:0 auto</code></li><li><code>display:absolute;top:50%；left:50%;margin-left:-50%*width;margin-top:-50%*height</code></li><li><code>grid</code>(不会用，仅知道)</li></ol><h5 id="string-trim"><a href="#string-trim" class="headerlink" title="string.trim"></a>string.trim</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim2=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)|(\s*$)/</span>,<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2=<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self=<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="cookie-sessionStorage-localStorage"><a href="#cookie-sessionStorage-localStorage" class="headerlink" title="cookie,sessionStorage,localStorage"></a><code>cookie,sessionStorage,localStorage</code></h5><blockquote><p><code>cookie,4KB</code></p><p><code>sessionStorage 5MB</code>(关闭浏览器，储存就没了)</p><p><code>localStorage 5MB</code>（没有人为清除一直保存）</p></blockquote><p>#####<code>ES6+新特性用过哪些</code></p><blockquote><ol><li>箭头函数</li><li>let，const</li><li>解构赋值，默认参数</li><li>[…arr]</li><li>promise</li><li>generator函数</li><li><code>async，await</code></li><li><code>padStart,padEnd</code>等</li></ol></blockquote><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p><code>static</code>不可以给实例调用</p><p>可以给子类调用，可被修改</p><p>私有变量，最好的办法：<code>weakMap</code>，避免内存泄露</p><h5 id="vue路由守卫"><a href="#vue路由守卫" class="headerlink" title="vue路由守卫"></a><code>vue</code>路由守卫</h5><blockquote><ol><li><code>beforeRouteLeave</code></li><li><code>beforeEach</code></li><li><code>beforeEnter</code></li><li><code>beforeRouteEnter</code></li><li><code>beforeRosolve</code></li><li><code>afterEach</code></li></ol><hr><ol start="7"><li><code>beforeCreate</code></li><li><code>created</code></li><li><code>beforeMount</code></li><li><code>deactived</code></li><li><code>mounted</code></li><li><code>actived</code></li></ol></blockquote><p><code>include</code>：缓存组件</p><p><code>exclude</code>:不缓存组件</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><ul><li><p><strong>声明提前</strong>: 一个声明在函数体内都是可见的, 函数优先于变量</p></li><li><p>非匿名自执行函数，函数变量为 <strong>只读</strong> 状态，无法修改</p></li></ul><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><h6 id="异步函数的回调方法即一个关联闭包"><a href="#异步函数的回调方法即一个关联闭包" class="headerlink" title="异步函数的回调方法即一个关联闭包"></a>异步函数的回调方法即一个关联闭包</h6><h2 id="POST-方法会产生两个TCP数据包？"><a href="#POST-方法会产生两个TCP数据包？" class="headerlink" title="POST 方法会产生两个TCP数据包？"></a>POST 方法会产生两个TCP数据包？</h2><blockquote><p><code>header</code> 和 <code>body</code>分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</p></blockquote><h5 id="URL-的最大长度是-2048-个字符"><a href="#URL-的最大长度是-2048-个字符" class="headerlink" title="URL 的最大长度是 2048 个字符?"></a>URL 的最大长度是 2048 个字符?</h5><blockquote><p><code>url</code> 长度限制是某些浏览器和服务器的限制，和 HTTP 协议没有关系。</p></blockquote><p>#####vue组件间的通信</p><blockquote><ul><li><p>父子通信（.sync,.native）</p></li><li><p>eventBus</p></li><li><p>vuex</p></li><li><p>跨级通信</p><p>派发与广播</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="string">'../mixins/emitter.js'</span></span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="keyword">export</span></span><br><span class="line">&gt;    </span><br><span class="line">&gt;   <span class="keyword">default</span>&#123;</span><br><span class="line">&gt;     mixins:[Emitter],</span><br><span class="line">&gt;     methods:&#123;</span><br><span class="line">&gt;       handleDispatch ()&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.dispatch();  <span class="comment">// ①   </span></span><br><span class="line">&gt;   &#125;,</span><br><span class="line">&gt;   handleBroadcast ()&#123;</span><br><span class="line">&gt;   <span class="keyword">this</span>.broadcast();  <span class="comment">// ② </span></span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;     </span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="comment">//emitter.js</span></span><br><span class="line">&gt;   broadcast...</span><br><span class="line">&gt;   dispatch...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>provide&amp;&amp;inject</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《我的阴阳两界》---王小波</title>
      <link href="/2019/03/04/myBlackWhiteWorld-wxb/"/>
      <url>/2019/03/04/myBlackWhiteWorld-wxb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>2019-03-04</code></p><p>​    看完王小波的《我的阴阳两界》后，虽然只花了一个下午，这也是我第二次接触王小波的语言。第一次是高三时候，语文老师在我麻木的时候给我们班发了段王小波的文字，那段文字颇为新颖，与柏杨的《丑陋的中国人》当时一样吸引着我。但是就在昨天也就是<code>2019-03-03</code>。我看完这本书后颇不是滋味，世界难道真的如这些小说家的不堪？</p><p>​    从小活在童话故事里的我总相信未来是个美好的结局。后来果不其然，我受了很多打击，失恋、生病、骨折、求学失败等等等等，就好像运气背的时候，什么都是冲着你来的。这便是我那时的世界。慢慢的，我从童话故事中醒了过来，觉得生活就那么回事，觉得自己做不了人上人，一生也不会有什么作为了。但是有一点，是我直到现在都很自豪与欣慰的，便是我的不甘。我用自己残存的意志开始思考人生在世的意义，学习人性的一切。生活慢慢得开始有盐有糖，好像那些黑暗年纪的时光都成为过眼云烟，如看一场电影，五味杂陈。</p><p>​    后来我又想来，人家写书的，愿意写啥就写啥，人家过人家的生活，管不着。我扬起这种心态来，这便是我自那之后的生活态度，万事都能想通，无欲无求。或许这就是佛系。后来，我渐渐开始有了年轻人该有的奋斗目标与活力，才开始重新步入正轨，这也正是我休学了2年后的所得。</p><p>​    我静静的思考着为什么王小波这些文字能这么吸引人，无非就是他裸露的文字，把潜藏于中国人内心的性和叛逆给抒发出来。我看不清这背后的种种，但我明白这种文字粗俗的不能再粗俗，为什么王小波王老能火，源于中国人的劣根性，被骂醒的快感，被压迫久后，对反讽时政的支持。97年去世的王老能看清当时的一切，保持那份独特的心，不畏强权,着实令人敬佩。再转念一想，这作家，借古讽今朝朝都有，总是得到后人的推崇，我的想法却是，世界就算是这样又如何，你一个人不能改变世界又如何，难道我们不适应就该去死吗？适应了，你或许不再是你，但这才叫成长，哪能一帆风顺的，与其抱怨世界，不如磨平自己的棱角，变得温柔，开始欣赏生活的美。磕磕碰碰的你，再回首的那刻，你感到欣慰，欣慰那刻便属于我的幸福。王老能在那个年代保持属于自己的那份本心，也着实令人感到别样的魅力。毕竟如果人生道路一条，便不再是人生，而是通往坟墓的必经之门。世界以痛吻我，不求报之以歌，但求依然不倒于我的世界，爱我所爱，想我所想，肆意人生。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题3</title>
      <link href="/2019/02/26/answer3/"/>
      <url>/2019/02/26/answer3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="调用new的时候会发生哪些事情？"><a href="#调用new的时候会发生哪些事情？" class="headerlink" title="调用new的时候会发生哪些事情？"></a>调用new的时候会发生哪些事情？</h3><blockquote><ol><li>新生成一个对象</li><li>链接到原型</li><li>绑定this</li><li>返回新对象</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function create()&#123;</span><br><span class="line">    //新生成一个对象</span><br><span class="line">    let obj = new Object();</span><br><span class="line">    //获得构造函数</span><br><span class="line">    let Con = [].shift.call(arguments);</span><br><span class="line">    //链接到原型</span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line">    //绑定this</span><br><span class="line">    let result = Con.apply( obj , arguments )</span><br><span class="line">    确保new出来的是对象</span><br><span class="line">    return typeOf result == &apos;object&apos; ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceOf实现"><a href="#instanceOf实现" class="headerlink" title="instanceOf实现"></a><code>instanceOf</code>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//left是对象，right是类型</span><br><span class="line">function instanceOf(left,right)&#123;</span><br><span class="line">    let prototype=right.prototype;</span><br><span class="line">    let left=left.__proto__;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">     if(left===null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">     &#125;else if(prototype===left)&#123;</span><br><span class="line">            return true;</span><br><span class="line">     &#125;</span><br><span class="line">        left=left.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p><code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code></p><h5 id="promise实现（试着跟着注释敲出来）"><a href="#promise实现（试着跟着注释敲出来）" class="headerlink" title="promise实现（试着跟着注释敲出来）"></a><code>promise</code>实现（试着跟着注释敲出来）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"><span class="comment">// promise 接收一个函数参数，该函数会立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this=<span class="keyword">this</span>;</span><br><span class="line">    _this.currentState=PENDING;</span><br><span class="line">    _this.value=<span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用于保存 then 中的回调，只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.resolvedCallbacks=[];</span><br><span class="line">    _this.rejectedCallbacks=[];</span><br><span class="line">    _this.resolve=<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 如果 value 是个 Promise，递归执行</span></span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line">           <span class="keyword">return</span> value.then(_this.resolve,_this.reject)</span><br><span class="line">           &#125;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">            <span class="keyword">if</span>(_this.currentState === PENDING)&#123;</span><br><span class="line">               _this.currentState = RESOLVED;</span><br><span class="line">                _this.value=value;</span><br><span class="line">                _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span>=&gt;</span>cb());</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//reject</span></span><br><span class="line">        _this.reject=<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">                <span class="keyword">if</span>(_this.currentState === PENDING)&#123;</span><br><span class="line">                   _this.currentState = REJECTED;</span><br><span class="line">                   _this.value=reson;</span><br><span class="line">                   _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span>=&gt;</span>cb()) </span><br><span class="line">                   &#125;    </span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">             <span class="comment">// 用于解决以下问题</span></span><br><span class="line">  <span class="comment">// new Promise(() =&gt; throw Error('error))</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                fn(_this.resolve,_this.reject);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                _this.reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//then方法在promise的原型上</span></span><br><span class="line">    MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self=<span class="keyword">this</span>;</span><br><span class="line">              <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">            <span class="keyword">var</span> newPromise;</span><br><span class="line">  <span class="comment">// 规范 2.2.onResolved 和 onRejected 都为可选参数</span></span><br><span class="line">  <span class="comment">// 如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line">  <span class="comment">// Promise.resolve(4).then().then((value) =&gt; console.log(value))</span></span><br><span class="line">            onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">            onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> <span class="keyword">throw</span> r;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(self.currentState === RESOLVED) &#123;</span><br><span class="line">                <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line">         <span class="comment">// 所以用了 setTimeout 包裹下</span></span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">var</span> x = onResolved(self.value);</span><br><span class="line">                            resolutionProcedure( newPromise , x , resolve , reject)</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(reason)&#123;</span><br><span class="line">                            reject(reason);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;))</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">if</span>(self.currentState === REJECTED)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function">(<span class="params">newPromise= <span class="keyword">new</span> MyPromise((resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">var</span> x = onRejected(self.value)</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(reason)&#123;</span><br><span class="line">                            reject(reason)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">if</span>(self.currentState === PENDING)&#123;</span><br><span class="line">                <span class="keyword">return</span><span class="function">(<span class="params">newPromise = <span class="keyword">new</span> MyPromise((resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                    self.resolveCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="keyword">var</span> x = onResolved(self.value) </span><br><span class="line">                            resolutionProcedure( newPromise , x , resolve , reject)</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(reason)&#123;</span><br><span class="line">                            reject(reason);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                 </span><br><span class="line">                &#125;))</span><br><span class="line">                self.rejectCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> x = onRejected(self.value);</span><br><span class="line">                        resolutionProcedure( newPromise , x , resolve , reject)</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(reason)&#123;</span><br><span class="line">                        reject(reason);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">newPromise , x ,resolve , reject</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">            <span class="keyword">if</span>(newPromise === x)&#123;</span><br><span class="line">               <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>));</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="comment">// 规范 2.3.2</span></span><br><span class="line">  <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">            <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x.currentState ===PENDING)&#123;</span><br><span class="line">                    x.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">                        resolutionProcedure(newPromise,value,resolve,reject)</span><br><span class="line">                    &#125;,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    x.then(resolve,reject)</span><br><span class="line">                &#125;   </span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">    <span class="comment">// reject 或者 resolve 其中一个执行过得话，忽略其他的</span></span><br><span class="line">            <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">             <span class="comment">// 规范 2.3.3，判断 x 是否为对象或者函数</span></span><br><span class="line">            <span class="keyword">if</span>(x !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> x ===<span class="string">"object"</span> || <span class="keyword">typeof</span> x ===<span class="string">"function"</span>)&#123;</span><br><span class="line"> <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> then=x.then;</span><br><span class="line">                     <span class="comment">// 如果 then 是函数，调用 x.then</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                        then.call(x,</span><br><span class="line">                                   y=&gt;&#123;</span><br><span class="line">                           <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                             called=<span class="literal">true</span>;</span><br><span class="line">                          resolutionProedure(newPromise,y,resolve,reject);    </span><br><span class="line">                         &#125;,</span><br><span class="line">                             e=&gt;&#123;</span><br><span class="line">                            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                             called=<span class="literal">true</span>;</span><br><span class="line">                             reject(e);</span><br><span class="line">                         &#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ps:好难理清思路，大概路线算是理清了，细节还得花点时间。</span></span><br></pre></td></tr></table></figure><p>#####<code>Event Loop</code>在<code>Node</code>中与<code></code>浏览器`中有啥区别</p><p>Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p><h5 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h5><blockquote><ol><li>处理<code>HTML</code>并构建<code>Dom</code>树</li><li>处理<code>CSS</code>并构建<code>CSSom</code>树</li><li>将<code>dom</code>与<code>CSSom</code>树合并为渲染树</li><li>根据渲染树布局，计算每个节点的位置</li><li>调用<code>GPU</code>绘制，合成图层，显示在屏幕上</li></ol></blockquote><h5 id="重绘（Repaint）和回流（Reflow）"><a href="#重绘（Repaint）和回流（Reflow）" class="headerlink" title="重绘（Repaint）和回流（Reflow）"></a>重绘（Repaint）和回流（Reflow）</h5><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li></ul><h5 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h5><ul><li><p>使用 <code>translate</code> 替代 <code>top</code></p></li><li><p>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p></li><li><p>把 <code>DOM</code>离线后修改，比如：先把 DOM 给 <code>display:none</code> (有一次 <code>Reflow</code>)，然后你修改 100 次，然后再把它显示出来</p></li></ul><ul><li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code> 标签，浏览器会自动将该节点变为图层。</li></ul><h5 id="预加载与预渲染"><a href="#预加载与预渲染" class="headerlink" title="预加载与预渲染"></a>预加载与预渲染</h5><blockquote><p><em>预加载</em>：<code>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</code></p></blockquote><blockquote><p>预渲染：<code>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</code></p></blockquote><p><strong>跨网站指令码</strong>（英语：Cross-site scripting，通常简称为：<code>XSS</code>）是一种网站应用程式的安全漏洞攻击，是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E7%A2%BC%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">代码注入</a>的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。<code>XSS</code> 分为三种：反射型，存储型和 DOM-based</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xss = <span class="built_in">require</span>(<span class="string">'xss'</span>)</span><br><span class="line"><span class="keyword">var</span> html = xss(<span class="string">'&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;'</span>)</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure><p>以上示例使用了 <code>js-xss</code> 来实现。可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签</p><h3 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a><code>CSP</code></h3><blockquote><p>内容安全策略 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP" target="_blank" rel="noopener">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS" target="_blank" rel="noopener">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p></blockquote><p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p><ul><li><p>只允许加载本站资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src ‘self’</span><br></pre></td></tr></table></figure></li><li><p>只允许加载 HTTPS 协议图片</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: img-src https://*</span><br></pre></td></tr></table></figure></li><li><p>允许加载任何来源框架</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: child-src 'none'</span><br></pre></td></tr></table></figure></li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><blockquote><p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong>或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0#citenoteRistic1" target="_blank" rel="noopener">[1]</a> 跟<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noopener">跨網站指令碼</a>（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p></blockquote><p>简单点说，<code>CSRF</code> 就是利用用户的登录态发起恶意请求。</p><p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.domain.com/xxx?comment='attack'"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.domain.com/xxx"</span> <span class="attr">id</span>=<span class="string">"CSRF"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"comment"</span> <span class="attr">value</span>=<span class="string">"attack"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>防范 CSRF 可以遵循以下几种规则：</p><ol><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 token</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《增长黑客》</title>
      <link href="/2019/02/26/addHooker/"/>
      <url>/2019/02/26/addHooker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>2019-02-24更</code></p><p>###《增长黑客》第一章—-&gt;增长黑客的崛起</p><blockquote><p><code>你不可能从现在预测未来，只有回头看时，才会发现事物之间的联系。所以你必须相信，那些生命中的点点滴滴，将在你未来的生命里，以某种方式串联起来。你必须相信一些东西——你的勇气，宿命，生活，因缘，随便什么，它们将给你追寻内心真正所想的自信，带你走离平凡，变得与众不同</code></p><p><code>增长黑客是集产品的设计开发与未来走向的定制与依靠数据大胆预测的职位</code></p><p><code>增长黑客就是通过数据分析快速找到机会和问题，并迅速地设置各种规模的实验去验证，找到可持续的方法来增长</code></p></blockquote><p><code>2019-2-26更</code></p><p>###《增长黑客》第二章—-&gt;创造正确的产品</p><p>摘抄：</p><blockquote><p>​    <code>要么调转方向，精简功能，孤注一掷地抓住一两个用户核心需求做精做专。  ---Burbn</code></p><p>​    <code>PMF</code> —–&gt;<code>Product/Market Fit产品与市场相契合</code></p><p>​    <code>不能盲目得去生产产品而浪费资源，以及给用户产生不好的映像。</code></p></blockquote><h5 id="判断需求是否够大"><a href="#判断需求是否够大" class="headerlink" title="判断需求是否够大"></a>判断需求是否够大</h5><ol><li><p>先估计目标用户的基数的基数、消费能力、意愿预算，再把这些数字相乘等方式得出一个大概数字，并于该行业或近似行业的公开报告进大型比对验证；</p></li><li><p>评估打算进入的市场，原本具有多少产值，而你的产品通过提供最低的价格、更长的使用周期等，能提升多少效率、节省多少成本，从而折算出相对于原产值的全新规模</p><p><code>ps:推进百度搜索风云榜，百度指数等</code></p></li></ol><h5 id="衡量需求变现的能力"><a href="#衡量需求变现的能力" class="headerlink" title="衡量需求变现的能力"></a>衡量需求变现的能力</h5><p>答：寻找合适市场机会，拟定产品方向和发展策略</p><h5 id="MVP-gt-Minumum-Viable-Product"><a href="#MVP-gt-Minumum-Viable-Product" class="headerlink" title="MVP---&gt;Minumum Viable Product"></a><code>MVP---&gt;Minumum Viable Product</code></h5><p>答：</p><blockquote><ol><li><code>MVP用于解答商业产品开发中最重要的两个问题：①价值假设：产品是否满足用户的需求②增长假设：用户是否愿意为产品买单</code></li><li><code>用户反馈：用户的反馈应当作为产品开发中决策的根本依据</code></li><li><code>快速迭代</code></li><li><code>建议基于微信的MVP开发策略</code></li><li><code>MVP必备的三大模块：Ⅰ反馈渠道Ⅱ官方公告3.自动升级</code></li></ol></blockquote><h5 id="做法细节建议"><a href="#做法细节建议" class="headerlink" title="做法细节建议"></a><code>做法细节建议</code></h5><blockquote><ol><li><code>产品优化，待核心流程在目标人群的主流运行环境中跑通，再公开发布；</code></li><li><code>对可能造成严重影响的问题，事先通知用户，降低预期，减小因心理落差造成的不满</code></li><li><code>提前准备补救错是(特别是这种涉及付费的产品)和公关说辞，降低用户怨气，弥补经济损失，是指可以给予奖励</code></li><li><code>在产品中设置方便的反馈渠道</code></li><li><code>在未建立信任之前，不要让用户填写个人信息，可以匿名摸索和熟悉，再进行逐步引导</code></li></ol></blockquote><p><code>2019-02-28更</code></p><h3 id="《增长黑客》第三章—-gt-获取用户"><a href="#《增长黑客》第三章—-gt-获取用户" class="headerlink" title="《增长黑客》第三章—-&gt;获取用户"></a>《增长黑客》第三章—-&gt;获取用户</h3><h5 id="筛选种子用户"><a href="#筛选种子用户" class="headerlink" title="筛选种子用户"></a>筛选种子用户</h5><blockquote><p><strong><code>种子用户的定义</code></strong>：</p><ol><li><p><code>这批人数量少，获取不易</code></p></li><li><p><code>他们进入产品阶段较早</code></p></li><li><p><code>种子用户如同种子一样孕育着希望，具有长成参天大树的可能性</code></p><p><code>注:高质量的女性往往是重要的种子用户群体</code></p></li></ol></blockquote><h5 id="警惕产品蝗虫"><a href="#警惕产品蝗虫" class="headerlink" title="警惕产品蝗虫"></a>警惕产品蝗虫</h5><blockquote><ul><li><code>占用原本属于目标用户的名额</code></li><li><code>对社区生态造成伤害</code></li><li><code>喜欢提意见，且称为“用户体验”</code></li></ul></blockquote><h5 id="学会从社交网络获取海量用户"><a href="#学会从社交网络获取海量用户" class="headerlink" title="学会从社交网络获取海量用户"></a>学会从社交网络获取海量用户</h5><h5 id="用数据抓取“借鸡下蛋”"><a href="#用数据抓取“借鸡下蛋”" class="headerlink" title="用数据抓取“借鸡下蛋”"></a>用数据抓取“借鸡下蛋”</h5><blockquote><p>用爬虫抓取内容，使初创产品有内容，不显得骨感</p></blockquote><h5 id="内容营销：打造持续输出的传播引擎"><a href="#内容营销：打造持续输出的传播引擎" class="headerlink" title="内容营销：打造持续输出的传播引擎"></a>内容营销：打造持续输出的传播引擎</h5><blockquote><ul><li>讲用户爱听的故事<ul><li>吸引流量</li><li>培养潜在用户</li><li>劝诱转化</li></ul></li><li>内容营销的注意事项<ul><li>知道你的目标受众是谁</li><li>打造一台内容持续输出的引擎</li><li>撰写耸动的标题</li><li>保证文章的长度<code>&gt;3000字&amp;&amp;&lt;10000字</code></li><li>鼓励受众参与互动</li><li>选择合适的发补渠道</li></ul></li></ul></blockquote><h5 id="搜索引擎和应用商店的优化营销"><a href="#搜索引擎和应用商店的优化营销" class="headerlink" title="搜索引擎和应用商店的优化营销"></a>搜索引擎和应用商店的优化营销</h5><blockquote><ul><li>搜索引擎优化</li><li>应用商店优化</li></ul></blockquote><h5 id="捆绑下载"><a href="#捆绑下载" class="headerlink" title="捆绑下载"></a>捆绑下载</h5><h5 id="排排坐，吃果果—-gt-即排队让用户使用"><a href="#排排坐，吃果果—-gt-即排队让用户使用" class="headerlink" title="排排坐，吃果果—&gt;即排队让用户使用"></a>排排坐，吃果果—&gt;即排队让用户使用</h5><h5 id="嵌入式代码和小挂件让你的品牌无处不在"><a href="#嵌入式代码和小挂件让你的品牌无处不在" class="headerlink" title="嵌入式代码和小挂件让你的品牌无处不在"></a>嵌入式代码和小挂件让你的品牌无处不在</h5><h5 id="宣传文案的撰写"><a href="#宣传文案的撰写" class="headerlink" title="宣传文案的撰写"></a>宣传文案的撰写</h5><blockquote><p><code>优秀的文案，应当让读者有种坐滑梯的感觉，即顺着你预先铺设的轨道一路畅通地滑下去，走完全程，到达终点。而标题、副标题、题图的所有作用在于让读者阅读正文的第一句话；至于正文第一句话的核心价值，则是让读者继续阅读第二句话，以此类推。在整个阅读中，既要给读者提供足够的信息量而不嫌冗长，又要让你的读者说‘是’，让他们在阅读文案的过程中，因你得真诚实在的陈述而产生共鸣</code></p><ul><li>熟悉产品</li><li>头脑风暴</li><li>谋篇布局<ul><li>简要概述</li><li>话题事件</li><li>核心特色</li><li>主要功能</li><li>团队访谈</li><li>未来计划</li><li>推广活动</li><li>转化引导</li></ul></li></ul></blockquote><h3 id="《增长黑客》第五章"><a href="#《增长黑客》第五章" class="headerlink" title="《增长黑客》第五章"></a>《增长黑客》第五章</h3><p><code>2019-03-06更</code></p><p><code>ps:持续更</code></p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端面试题2</title>
      <link href="/2019/02/24/answer2/"/>
      <url>/2019/02/24/answer2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前端如何优化网站性能"><a href="#前端如何优化网站性能" class="headerlink" title="前端如何优化网站性能"></a>前端如何优化网站性能</h3><p>自己的总结：</p><blockquote><ol><li><code>js,css</code>压缩后发布</li><li>减少<code>dom</code>重排（<code>reflow</code>）</li><li><code>css sprites</code></li><li>使用图片懒加载</li><li>减少<code>http</code>请求，即<code>ajax</code></li></ol></blockquote><p>别人的总结</p><blockquote><ol><li>减少<code>http</code>请求</li><li>控制资源文件加载优先级—<code>css</code>在头部，<code>js</code>在底部</li><li>利用浏览器缓存</li><li>减少重排</li><li>减少<code>dom</code>操作</li></ol></blockquote><h3 id="网页从输入网址到渲染完成经历了哪些过程"><a href="#网页从输入网址到渲染完成经历了哪些过程" class="headerlink" title="网页从输入网址到渲染完成经历了哪些过程"></a>网页从输入网址到渲染完成经历了哪些过程</h3><p>7步：</p><blockquote><ol><li>输入网址</li><li>发送到<code>DNS</code>服务器，解析域名对应的<code>IP</code>地址</li><li>与web服务器建立TCP连接</li><li>浏览器向web发送HTTP请求</li><li>web服务器响应请求，并返回数据</li><li>浏览器下载数据解析html源文件</li><li>生成<code>dom</code>树，解析<code>css和js</code>，渲染页面</li></ol></blockquote><h3 id="写React-Vue项目时为什么要在组件中写key，其作用是什么"><a href="#写React-Vue项目时为什么要在组件中写key，其作用是什么" class="headerlink" title="写React/Vue项目时为什么要在组件中写key，其作用是什么"></a>写React/Vue项目时为什么要在组件中写key，其作用是什么</h3><p>答：key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。</p><h3 id="解析-39-1-39-39-2-39-39-3-39-map-parseInt"><a href="#解析-39-1-39-39-2-39-39-3-39-map-parseInt" class="headerlink" title="解析[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)"></a>解析<code>[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)</code></h3><p>答案<code>[1,NaN,NaN]</code></p><p>map函数第一个参数callback，一共接受三个参数，第一个参数带包当前被处理的元素，第二个参数代表该元素的索引</p><p><code>parseInt(string,radix)</code>，string处理值，radix是解析的基数</p><p><code>parseInt(&#39;1&#39;,0)</code>,radix为0时，且string参数不以‘0x’,’0’开头时，按照十进制处理，这时候返回1</p><p><code>parseInt(&#39;2&#39;,1)</code>,1进制，最大值小于2，无法解析，返回NaN;</p><p><code>parseInt(&#39;3&#39;,2)</code>，同上理</p><p>map返回的是一个数组</p><h3 id="什么是防抖和节流？有什么区别？如何实现"><a href="#什么是防抖和节流？有什么区别？如何实现" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现"></a>什么是防抖和节流？有什么区别？如何实现</h3><p><strong>防抖</strong>：触发高频事件后N秒内函数只会执行一次，如果N秒内高频事件再次触发，则重新计算时间</p><p>实现方法：每次触发事件时并且在取消之前延时调用</p><p><strong>节流</strong>：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p><p>实现方法：每次触发是按时判断当前是否有等待执行的延时函数</p><h3 id="介绍下Set、Map、WeakSet和WeakMap的区别？"><a href="#介绍下Set、Map、WeakSet和WeakMap的区别？" class="headerlink" title="介绍下Set、Map、WeakSet和WeakMap的区别？"></a>介绍下Set、Map、WeakSet和WeakMap的区别？</h3><p>Set:</p><p>·成员唯一、无序且不重复</p><p>·只有键值没有键名（键值和键名一样）</p><p>·可以遍历，方法有：add、delete、has</p><p><code>WeakSet</code>（不是很懂成员为对象的意思）</p><p>·成员都是<strong>对象</strong></p><p>·成员都是<strong>弱引用</strong>，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄露</p><p>`<strong>不能遍历</strong>，方法有：add、delete、has</p><p>Map</p><p>·本质上时键值对的集合，类似集合；</p><p>·可以遍历，方法很多，可以跟各种数据格式转换</p><p><code>WeakMap</code>(这个暂时没弄明白，等以后接触了再彻底弄明白)</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><code>async</code>和<code>promise</code>中的代码是立即执行的，即同步的</p><p>await和then，catch是异步的</p><h3 id="将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组"><a href="#将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组" class="headerlink" title="将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组"></a>将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.from(new Set(arr.flat(Infinity))).sort((a,b)=&gt;&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>flat是<code>es6</code>新出来的，Array.from是将其中的set对象转换为真正数组</p><p>字符串和 Set 结构都具有 Iterator 接口，因此可以被<code>Array.from</code>转为真正的数组。</p><h3 id="谈谈你对TCP三次握手和四次挥手的理解"><a href="#谈谈你对TCP三次握手和四次挥手的理解" class="headerlink" title="谈谈你对TCP三次握手和四次挥手的理解"></a>谈谈你对TCP三次握手和四次挥手的理解</h3><p>从上到下分别是：</p><h5 id="7-应用层-Application"><a href="#7-应用层-Application" class="headerlink" title="7.应用层(Application)"></a>7.应用层(Application)</h5><h5 id="6-表示层-Presentation"><a href="#6-表示层-Presentation" class="headerlink" title="6.表示层(Presentation)"></a>6.表示层(Presentation)</h5><h5 id="5-会话层-Session"><a href="#5-会话层-Session" class="headerlink" title="5.会话层(Session)"></a>5.会话层(Session)</h5><h5 id="4-传输层-Transport-，tcp的所在"><a href="#4-传输层-Transport-，tcp的所在" class="headerlink" title="4.传输层(Transport)，tcp的所在"></a>4.传输层(Transport)，tcp的所在</h5><h5 id="3-网络层-Network-–-路由器ip"><a href="#3-网络层-Network-–-路由器ip" class="headerlink" title="3.网络层(Network)    – 路由器ip"></a>3.网络层(Network)    – 路由器ip</h5><h5 id="2-数据链路层-Data-Link-–-交换机"><a href="#2-数据链路层-Data-Link-–-交换机" class="headerlink" title="2.数据链路层(Data Link) – 交换机"></a>2.数据链路层(Data Link) – 交换机</h5><h5 id="1-物理层-Physical-–-网卡、集线器（Hub）"><a href="#1-物理层-Physical-–-网卡、集线器（Hub）" class="headerlink" title="1.物理层(Physical) – 网卡、集线器（Hub）"></a>1.物理层(Physical) – 网卡、集线器（Hub）</h5>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019-plan</title>
      <link href="/2019/02/24/2019-plan/"/>
      <url>/2019/02/24/2019-plan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="新年计划"><a href="#新年计划" class="headerlink" title="新年计划"></a>新年计划</h3><blockquote><ol><li>看50本书</li><li>写博客</li><li>瘦20斤</li><li>进互联网大厂实习</li></ol></blockquote><p>受之前的一个朋友的启发，我打算今年看50本书，以下是我整理的书单。（参考豆瓣）</p><p>第一步要看的便是豆瓣2018年最火的1.《失踪的孩子》，看评论前，我曾经自大的以为自己能对人性有所了解，看完评论，我深刻感受到人生的沧桑，以及生而为人的悲哀，同时又感受到悬崖勒马的庆幸。具体还是看完再写吧。</p><p>2.《今日简史》，3.《人类简史》，4.《未来简史》</p><ol start="5"><li>《情感s勒索》</li><li>《我要快乐，不必正常》</li><li>《极简》</li><li>《刷新》萨提亚·纳德拉</li><li>《一只特立独行的猪》王小波</li><li>《变量》何帆</li><li>《我们三》杨绛</li><li>《增长黑客》</li></ol><p>之后会加</p>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第四范式前端面试题错题（牛客网）</title>
      <link href="/2019/02/24/answer1/"/>
      <url>/2019/02/24/answer1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="第四范式前端面试题错题（牛客网）"><a href="#第四范式前端面试题错题（牛客网）" class="headerlink" title="第四范式前端面试题错题（牛客网）"></a>第四范式前端面试题错题（牛客网）</h3><blockquote><ol><li>W3C标准盒模型中，默认情况下块元素的总宽度为</li></ol><p>content，此题考查W3C与IE盒模型的区别，</p><p>W3C的块元素的总宽度指块元素的内容宽度而不是指的盒子宽度。即为content。</p><p>而IE盒模型块元素的总宽度就等于content+2*padding+2*border</p><ol start="2"><li><p>通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0</p></li><li><p><strong>箭头函数不能当构造器使用</strong></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;   compute(10,100)</span><br><span class="line">&gt;   var compute=function(A,B)&#123;</span><br><span class="line">&gt;    console.info(A*B)</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   function compute(A,B)&#123;</span><br><span class="line">&gt;    console.info(A+B)</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   function compute(A,B)&#123;</span><br><span class="line">&gt;    console.info((A+B)*2)</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   compute(2,10)</span><br><span class="line">&gt;   //220,20</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>20的问题是如下原因 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var compute;</span><br><span class="line">&gt; funtion compute(A,B)&#123;</span><br><span class="line">&gt;  console.info(A+B)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; function compute(A,B)&#123;</span><br><span class="line">&gt;  console.info((A+B)*2)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; compute = function(A,B)&#123;</span><br><span class="line">&gt;  console.info(A*B)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="5"><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   var arr = [];</span><br><span class="line">&gt;   console.log(typeof arr, Object.prototype.toString.call(arr))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>Object,[Object,Array]</p><p>let arr=[1,2,3]</p><p>Array.toString(arr)与Object.prototype.toString.call(arr)</p><p>“1,2,3”,[Object,Array]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; 6.</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>let a = {<br><code>`</code></p><p>age: undefined,</p><p>jobs: function() {},</p><p>name: ‘yck’</p><p>}</p><p>let b = JSON.parse(JSON.stringify(a))<br>//如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝<br>console.log(b)//{name: “yck”}<br>//在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化<br>//undefined用JSON.stringify时不会拷贝的</p><p>//object.assign()不会将null，undefined忽略([继承属性和不可枚举属性是不能拷贝的])</p><p>//object.assign拷贝的是属性值</p><p>//object.assign()不会深拷贝二维数组或者对象里的对象即无法实现真正意义上的深拷贝<br>//lodash深拷贝函数可以完成深拷贝cloneDeep，cloneDeepWidth</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指offer遇到的问题与nginx配置</title>
      <link href="/2019/02/12/offer&amp;&amp;nginx/"/>
      <url>/2019/02/12/offer&amp;&amp;nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="map-要return"><a href="#map-要return" class="headerlink" title="map 要return"></a>map 要return</h3><ol><li>map要return</li><li>map 要return</li><li>map 要return</li></ol><h3 id="forEach中的return与for循环的return-不一样！！！"><a href="#forEach中的return与for循环的return-不一样！！！" class="headerlink" title="forEach中的return与for循环的return 不一样！！！"></a>forEach中的return与for循环的return 不一样！！！</h3><p>for 循环里面 return 可以直接终止 跳出 循环</p><p>forEach 是中断本次循环 直接 下一个循环 forEach想要取到值之后 直接跳出循环 可以用 try catch</p><p>let arr = [0, 1, 2, 3, 4, 5, 6]<br>try{<br>arr.forEach((item) =&gt; {<br>if (item === 3) {<br>throw ‘Jump out now!’//在这里抛出异常<br>}<br>console.log(item)<br>})<br>} catch (e) {<br>console.log(e)<br>}</p><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><ol><li><p>nginx要用任务管理器关闭 或者 用 ps -ef|grep nginx，kill -QUIT 进程号</p></li><li><p>nginx配置：前端配置时，sever_name为127.0.0.1</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location  ^~ /api/ &#123;</span><br><span class="line">            proxy_pass  http://ip:port/;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注：<strong><a href="http://ip:port后面必须加/" target="_blank" rel="noopener">http://ip:port后面必须加/</a></strong></p></li></ol><p>基本上这样项目就能跑起来了</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js常用设计模式</title>
      <link href="/2019/02/12/jsDesignMode/"/>
      <url>/2019/02/12/jsDesignMode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><strong>中介者的功能就是封装对象之间的交互。如果一个对象的操作会引起其他相关对象的变化，而这个对象又不希望自己来处理这些关系，那么就可以去找中介者，让它来处理这些麻烦的关系。</strong> </p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p><strong>享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态</strong>，下面的几条经验提供了一些指引</p><p>　&gt;　1、内部状态存储于对象内部。<br>　&gt;<br>　&gt;　2、内部状态可以被一些对象共享。<br>　&gt;<br>　&gt;　3、内部状态独立于具体的场景，通常不会改变。<br>　&gt;<br>　&gt;　4、外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote><p>​    代理（proxy）是一个对象，它可以用来控制对另外一个对象的访问；</p><p>​    代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；</p></blockquote><p> <strong>与装饰者模式的区别</strong></p><blockquote><p>​    相同之处：都要对其他对象进行包装，都要事先与被包装对象相同的接口，而且都要把方法调用传递给被包装的对象。</p><pre><code>不同之处：一是装饰者会对被包装对象的功能进行修改或扩充，但是代理只不过是控制对它的访问；二是被包装对象的创建方式上：装饰者模式被包装对象的实例化过程完全是独立的，而在代理模式中，被包装对象的实例化是代理的实例化过程的一部分。</code></pre></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>只存在一个</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; singleton.getInstance = function(name) &#123;</span><br><span class="line">&gt;   if (!this.instance) &#123;</span><br><span class="line">&gt;     // 关键语句</span><br><span class="line">&gt;     this.instance = new Singleton(name);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   return this.instance;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="发布订阅模式-观察者模式"><a href="#发布订阅模式-观察者模式" class="headerlink" title="发布订阅模式(观察者模式)"></a>发布订阅模式(观察者模式)</h3><p> 　　<strong>发布—订阅模式，也就是常说的观察者模式，它的优点非常明显，一为时间上的解耦，二为对象之间的解耦。应用也非常广泛，既可以用在异步编程中，也可以帮助完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是MVC还是MVVM，都少不了发布—订阅模式的参与，而且javascript本身也是一门基于事件驱动的语言</strong> </p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p><strong>用来对方法调用进行参数化处理和传送，经过这样处理过的方法调用可以在任何需要的时候执行。也就是说该模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一些列的处理。他也可以用来消除调用操作的对象和实现操作的对象之间的耦合。这为各种具体的类的更换带来了极大的灵活性。</strong></p><p> 模式作用：</p><blockquote><p>1、将函数的封装、请求、调用结合为一体</p><p>2、调用具体的函数解耦命令对象与接收对象</p><p>3、提高程序模块化的灵活性</p></blockquote><h3 id="模板方法类"><a href="#模板方法类" class="headerlink" title="模板方法类"></a>模板方法类</h3><p><strong>模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</strong></p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p><strong>状态模式定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成： </strong></p><blockquote><p>（1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。</p><p> （2）状态类：表示一种状态，包含其相应的处理方法 </p></blockquote><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换(具有相同的目标和意图)</strong></p><blockquote><p>策略模式的优点:</p><p>​    1.策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句　</p><p>​    2.策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展</p><p>策略模式的缺点:　　</p><p>​    1.会在程序中增加许多策略类或者策略对象，但实际上比把他们负责的逻辑堆砌在 Context 中要好　</p><p>​    2.使用策略模式，必须了解所有的策略，才能更好的选择一个合适的策略</p></blockquote><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p><strong>责任链接模式又称职责链模式，是一种对象的行为模式；它是一种链式结构，每个节点都有可能两种操作，要么处理该请求停止该请求操作，要么把请求转发到下一个节点，让下一个节点来处理请求；该模式定义了一些可能的处理请求的节点对象，请求的起点跟顺序都可能不一样，处理的节点根据请求的不一样而不同；请求者不必知道数据处理完成是由谁来操作的，内部是一个黑箱的操作过程，这是它的一个核心内容；</strong></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p><strong>在不改变对象自身的基础上，在程序运行期间给对象动态地添加一些额外职责 </strong></p><blockquote><p>​    缺点：</p><ul><li>超类子类强耦合，超类改变导致子类改变</li><li>超类内部细节对子类可见，破坏了封装性</li><li>完成功能复用同时，可能会创造大量子类</li></ul></blockquote><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。 </strong></p><blockquote><p>​    特点：</p><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。</li></ul></blockquote><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong>将一个类（对象）的接口（方法或者属性）转化成另外一个接口以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。 </strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECM管理员端实习打卡系统</title>
      <link href="/2019/02/12/ECMstudying/"/>
      <url>/2019/02/12/ECMstudying/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ECM端管理员实习生打卡系统的学习历程"><a href="#ECM端管理员实习生打卡系统的学习历程" class="headerlink" title="ECM端管理员实习生打卡系统的学习历程"></a>ECM端管理员实习生打卡系统的学习历程</h3><ol><li><p>用xlsx库导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import XLSX from &apos;xlsx&apos;</span><br><span class="line">const importtf = (id) =&gt; &#123;</span><br><span class="line">    let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      // 导入</span><br><span class="line">      // FileReader共有4种读取方法：</span><br><span class="line">      // 1.readAsArrayBuffer(file) ：将文件读取为ArrayBuffer。</span><br><span class="line">      // 2.readAsBinaryString(file) ：将文件读取为二进制字符串</span><br><span class="line">      // 3.readAsDataURL(file) ：将文件读取为Data URL</span><br><span class="line">      // 4.readAsText(file, [encoding]) ：将文件读取为文本，encoding缺省值为&apos;UTF-8&apos;</span><br><span class="line">      var wb // 读取完成的数据</span><br><span class="line">      var rABS = false // 是否将文件读取为二进制字符串</span><br><span class="line">      let obj = document.getElementById(id)</span><br><span class="line">      if (!obj.files) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      var f = obj.files[0]</span><br><span class="line">      var reader = new FileReader()</span><br><span class="line">      if (rABS) &#123;</span><br><span class="line">        reader.readAsArrayBuffer(f)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reader.readAsBinaryString(f)</span><br><span class="line">      &#125;</span><br><span class="line">      var arr = []</span><br><span class="line">      reader.onload = function (e) &#123;</span><br><span class="line">        var data = e.target.result</span><br><span class="line">        if (rABS) &#123;</span><br><span class="line">          wb = XLSX.read(btoa(fixdata(data)), &#123; // 手动转化</span><br><span class="line">            type: &apos;base64&apos;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          wb = XLSX.read(data, &#123;</span><br><span class="line">            type: &apos;binary&apos;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        // wb.SheetNames[0]是获取Sheets中第一个Sheet的名字</span><br><span class="line">        // wb.Sheets[Sheet名]获取第一个Sheet的数据</span><br><span class="line">        arr = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]])</span><br><span class="line">        // console.log(JSON.stringify(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]])))</span><br><span class="line">        // console.log(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]))</span><br><span class="line">        // return XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]])</span><br><span class="line">        resolve(arr)</span><br><span class="line">      &#125;</span><br><span class="line">      reader.onerror = function (e) &#123;</span><br><span class="line">        reject(arr)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise</span><br><span class="line">  &#125;</span><br><span class="line">  const fixdata = (data) =&gt; &#123; // 文件流转BinaryString</span><br><span class="line">    var o = &apos;&apos;</span><br><span class="line">    var l = 0</span><br><span class="line">    var w = 10240</span><br><span class="line">    for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)))</span><br><span class="line">    o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)))</span><br><span class="line">    return o</span><br><span class="line">  &#125;</span><br><span class="line">  export default importtf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//挂载到原型上</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">....</span><br><span class="line">import importtf from &apos;@/util/util.js&apos;</span><br><span class="line">....</span><br><span class="line">Vue.prototype.$importtf = importtf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//使用</span><br><span class="line">importtf(id) &#123;</span><br><span class="line">      this.$importtf(id).then(file =&gt; &#123;</span><br><span class="line">        console.log(file);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li><p>用iview导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushOut() &#123;</span><br><span class="line">      this.$refs.tables.exportCsv(&#123;</span><br><span class="line">        filename: &quot;工作簿&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>3.坑：iview的i-table使用时，导出序号type=“index”并不起作用，要用key值，于是每渲染一条数据就得加上序号，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">showIndex()&#123;</span><br><span class="line">        var i = 0;</span><br><span class="line">        let newPage = JSON.parse(JSON.stringify(this.searchResultList));</span><br><span class="line">        this.searchResultList = newPage.map(k =&gt; &#123;</span><br><span class="line">        k.index = ++i;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>后台的坑：写了两个表tutor（导师）和stu（实习生），但是需要自己区分角色role，过程与上述方法类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//每次调用页面刷新都得调用这个函数以及上面的showIndex函数</span><br><span class="line">if(this.searchResultList.username)&#123;</span><br><span class="line">           this.addRole(this.searchResultList.username)</span><br><span class="line">         &#125;else if(this.searchResultList.tutorName)&#123;</span><br><span class="line">           this.addRole(this.searchResultList.tutorName)</span><br><span class="line">         &#125;</span><br><span class="line">    ...</span><br><span class="line">addRole(role) &#123;</span><br><span class="line">     let newPage = JSON.parse(JSON.stringify(this.searchResultList));</span><br><span class="line">     this.searchResultList = newPage.map(k =&gt; &#123;</span><br><span class="line">     k.role = role;</span><br><span class="line">     return k;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义指令</title>
      <link href="/2019/02/12/directive/"/>
      <url>/2019/02/12/directive/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>全局组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部注册组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: function (el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">el：指令所绑定的元素，可以用来直接操作 DOM 。</span><br><span class="line">binding：一个对象，包含以下属性：</span><br><span class="line">name：指令名，不包括 v- 前缀。</span><br><span class="line">value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。</span><br><span class="line">oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</span><br><span class="line">expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。</span><br><span class="line">arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。</span><br><span class="line">modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。</span><br><span class="line">vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</span><br><span class="line">oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue-router</title>
      <link href="/2019/01/02/vue-router/"/>
      <url>/2019/01/02/vue-router/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###vue-router的路由守卫的钩子函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照顺序的钩子函数</span><br><span class="line">beforeEach(to,from,next)&#123;&#125;,//全局</span><br><span class="line">beforeEnter(to,from,next)&#123;&#125;,//路由里面定义</span><br><span class="line">beforeRouteEach(to,from,next)&#123;&#125;,//组件</span><br><span class="line">beforeResolve(to,from,next)&#123;&#125;,//全局</span><br><span class="line">afterEach(to,from)&#123;&#125;//全局</span><br></pre></td></tr></table></figure><h3 id="额外的钩子函数"><a href="#额外的钩子函数" class="headerlink" title="额外的钩子函数"></a>额外的钩子函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate(to,from,next)&#123;&#125;,//组件</span><br><span class="line">beforeRouteLeave(to,from,next)&#123;&#125;//组件</span><br></pre></td></tr></table></figure><p>next()中可为next(“/“)或者next({path:”/“})</p><h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p>定义路由的时候可以配置meta字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta:&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>可使路由缓存，从而保存数据。上面的meta中可设置keep-alive定义其缓存与否。</p><h3 id="import优化性能"><a href="#import优化性能" class="headerlink" title="import优化性能"></a>import优化性能</h3><p>路由懒加载，需下载syntax-dynamic-import插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const _import_ = file =&gt; () =&gt; import(&apos;@/views/&apos; + file + &apos;.vue&apos;)</span><br></pre></td></tr></table></figure><h3 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h3><p>​    一般用以下代码滚动行为不会影响下一个路由</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">&gt;   <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> savedPosition</span><br><span class="line">&gt;   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><blockquote><p>to.params.id,from.params.id….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端项目总结</title>
      <link href="/2018/11/27/yidongduan/"/>
      <url>/2018/11/27/yidongduan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面说一些我在写移动端项目时总结的经验：</p><ul><li>我们知道移动端click点击事件有300s延迟，为了正常使用click，需引入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在main.js编写如下代码：</span><br></pre></td></tr></table></figure></li></ul><p>import fastClick from ‘fastclick’<br>fastClick.attach(document.body)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 低版本安卓浏览器打开一片白</span><br></pre></td></tr></table></figure></p><p>import ‘babel-polyfill’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 轮播图、横向滑动tab、图片放大滑动等这些使用```vue-awesome-swiper```插件</span><br></pre></td></tr></table></figure></p><p>import VueAwesomeSwiper from ‘vue-awesome-swiper’<br>import ‘swiper/dist/css/swiper.css’<br>Vue.use(VueAwesomeSwiper)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">具体使用场景需参照文档配置```option```选项，这里不再赘述。</span><br><span class="line">下面只阐述一点就是我们在使用插件时常常需要更改样式，比如改变轮播图下面小圆点的颜色。这里我们推荐使用**样式穿透**：</span><br><span class="line">  ```/deep/ ```是```sass```和```less```的样式穿透</span><br><span class="line">  ```&gt;&gt;&gt;```是```stylus```的样式穿透</span><br></pre></td></tr></table></figure></p><p> .wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active<br>    background: #fff<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">.wrapper  /deep/ .swiper-pagination-bullet-active &#123;</span><br><span class="line">    background: #fff</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>当我们要引入不是其本文件跟目录下的 css 文件时，记得使用<figure class="highlight plain"><figcaption><span>```来简化``` './../../....'```这些相对路径。或者使用```'~路径别名'```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">@import &apos;./../../../assets/css/mixin.scss&apos;;</span><br><span class="line">//简化成功</span><br><span class="line">@import &apos;~@/assets/css/mixin.scss&apos;;</span><br><span class="line">@import &apos;~styles/varibles.scss&apos;</span><br></pre></td></tr></table></figure></p></li><li><p>css常用相同模块内容可以提mixin提供多处使用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin omit &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后通过<code>@include</code>来调用具有相同名称的mixin模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">　@include omit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在css里面，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 可以进行提前占位，避免资源加载时候的闪烁</span><br><span class="line">2. 还可以让高度自适应</span><br><span class="line">在移动端或者在响应式开发情况下，我们可以利用这个特性来实现图片等比例缩放自适应。</span><br><span class="line">解决核心思想为：提供一个容器，设置容器的高度为0，再设置padding-bottom为56.25%（需要自适应的元素高度除以宽度*100%）（因为padding的百分比是按照容器宽度计算的，所以由padding来撑开容器高度，而不是height，保证了容器的宽高比例）</span><br></pre></td></tr></table></figure></li></ul><div class="wrapper"><br>  <img class="swiper-img"><br></div><p>.wrapper {<br>    overflow: hidden<br>    width: 100%<br>    height: 0<br>    padding-bottom: 31.25%<br>}<br>.swiper-img {<br>    width: 100%<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  移动端页面当滑动到底部时，路由跳转后发现页面还是保持在底部，这里可以在router中配置</span><br></pre></td></tr></table></figure></p><p>scrollBehavior (to, from, savedPosition) {<br>    return { x: 0, y: 0 }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 项目打包后，manifest.js可以理解为webpack打包生成的配置文件， vendor.js各个页面各个组件公用的一些代码，app.js放的是项目各个页面的业务逻辑代码。**app.js至少超过1M的时候才使用异步组件**</span><br><span class="line">* 使用keep-alive时有两个钩子函数:</span><br><span class="line">![877cd98ea39d2dcdce0918a0d9073d6.png](https://upload-images.jianshu.io/upload_images/5120924-9c48bbd34ef6b3e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure></p><p>mounted () {<br>    this.lastCity = this.city<br>    this.getHomeInfo()   //ajax请求<br>  },<br>  activated () {<br>    if (this.lastCity !== this.city) {<br>      this.lastCity = this.city<br>      this.getHomeInfo()<br>    }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 有一个移动端很常见的效果，当滑动右边部分的时候，左边会联动显示与当前内容相符合的标题高亮，当点击左边某一个标题的时候，右边会自动滑动到相应的内容。**左右联动效果**，可以通过```better-scroll```这个插件实现。另外，**横向滚动的导航栏**、**竖向滚动的列表**都可以通过这个插件来实现。</span><br></pre></td></tr></table></figure></p><p><template><br>    <!--定义外层--><br>    <div class="wrapper" ref="wrapper"><br>        <!--定义需要滚动的内容区域--><br>        <ul class="content"><br>            <li v-for="item in items"></li><br>        </ul><br>    </div><br></template></p><p><script><br>  import BScroll from ‘better-scroll’<br>  export default {<br>    mounted() {<br>      this.$nextTick(() =&gt; {<br>        this.scroll = new Bscroll(this.$refs.wrapper, {})<br>      })<br>    },<br>   watch: {<br>     letter () {<br>       if (this.letter) {<br>        const element = this.$refs[this.letter][0]<br>        this.scroll.scrollToElement(element)<br>      }<br>    }<br>   },<br>  }<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">样式这里需要注意的是，要滚动的这一部分给了固定的高度，且超出部分```overflow:hidden;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">    overflow: hidden</span><br><span class="line">    position: absolute</span><br><span class="line">    top: 1.58rem</span><br><span class="line">    left: 0</span><br><span class="line">    right: 0</span><br><span class="line">    bottom: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外附上better-scroll原作者的文章：<a href="https://www.imooc.com/article/18232" target="_blank" rel="noopener">https://www.imooc.com/article/18232</a></p><ul><li>我们做好的项目，如何在移动端进行调试呢？<br>我们发现，vue项目是用webpack-dev-server这个服务器跑起来的，这个服务器默认外部是无法访问的，需在package.json中加入<figure class="highlight plain"><figcaption><span>0.0.0.0```才行：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更改后的配置如下：</span><br></pre></td></tr></table></figure></li></ul><p>“scripts”: {<br>    “dev”: “webpack-dev-server –host 0.0.0.0 –inline –progress –config build/webpack.dev.conf.js”,<br>  },<br><code>这样的话，在命令行运行</code> ipconfig<code>`</code>，手机和电脑连接同一局域网，用手机访问电脑的ip地址就可以用真机打开啦</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hybrid初探</title>
      <link href="/2018/11/08/hybrid-first/"/>
      <url>/2018/11/08/hybrid-first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="hybrid实现"><a href="#hybrid实现" class="headerlink" title="hybrid实现"></a>hybrid实现</h3><blockquote><p>​    即客户端与前端和服务器三端的结合</p><p>​    hybrid混合开发app的应用的客户端即是所搭的框架，前端即是app的页面内容，服务器端即是保存和管理前端静态页的server上传等。</p><h5 id="怎么更改app的内容即前端部分？"><a href="#怎么更改app的内容即前端部分？" class="headerlink" title="怎么更改app的内容即前端部分？"></a>怎么更改app的内容即前端部分？</h5><p>答：通过自定义的版本号来定其是否应该更新</p><h5 id="为什么要用hybird而不用H5？"><a href="#为什么要用hybird而不用H5？" class="headerlink" title="为什么要用hybird而不用H5？"></a>为什么要用hybird而不用H5？</h5><p>答：1.hybird是通过file协议，而h5是通过https协议。file协议相对于http协议更快。</p><p>2.更新迭代速度更快</p></blockquote><p>体验虽然抵不上NA，但是上述两点有点足以让很多app都用hybrid，一般肉眼也看不清。</p>]]></content>
      
      
      <categories>
          
          <category> hybrid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hybrid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React视频观看总结</title>
      <link href="/2018/11/08/React-video-collect/"/>
      <url>/2018/11/08/React-video-collect/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>React是组件化的，而Vue是模板与js分离更彻底。</p><p>React用的是JSX标准（JSX为语法糖，需要被解析成js才能在浏览器中运行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">React: React.createElement(&quot;div&quot;,&#123;key:value&#125;,[...])</span><br><span class="line">Vue: h(&quot;div&quot;,onClick&#123;&#125;...) //代码即为VUE和React的生成虚拟dom的代码.</span><br></pre></td></tr></table></figure><p>React中的patch函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(container,...)这段代码将第一次执行patch函数，即patch(container,vnode),</span><br><span class="line">setState(&#123;...&#125;)这段代码将第二次执行patch函数，即patch(vnode,newVode)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(&#123;..&#125;)与vue的this....修改属性同样都是异步</span><br></pre></td></tr></table></figure><h3 id="为什么要是异步："><a href="#为什么要是异步：" class="headerlink" title="为什么要是异步："></a>为什么要是异步：</h3><blockquote><ol><li>函数是要给外界众多人用的，可以改变多次，用异步更优化性能</li><li>同名属性的修改不用向用户展示过程，只用展示结果</li></ol></blockquote><h3 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h3><blockquote><ol><li>组件的封装</li><li>组件的复用</li></ol></blockquote><h3 id="React与VUE的技术选型"><a href="#React与VUE的技术选型" class="headerlink" title="React与VUE的技术选型"></a>React与VUE的技术选型</h3><blockquote><ol><li>Vue更适合模板与js分离，React更适合组件化</li><li>Vue更适合小中型公司，学习成本相对不高，并且拿来直接用，生态圈也广，并且适合国内发展（个人理解）</li><li>React更适合大型公司的组件化开发，更适合复用</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数字格式化代码的详细解析</title>
      <link href="/2018/11/04/number/"/>
      <url>/2018/11/04/number/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###vue小技巧总结：</p><ol><li><p>~：图片、CSS变模块引入</p></li><li><p>@：src目录下</p></li><li><p>/** enter键：生成函数的参数、返回值以及对应的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建请求</span><br><span class="line"> * @param &#123;string&#125; URL 请求地址</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li><li><p>大佬一般将文件放一个index和其他的命名moduels，index负责导出这些命名的moduels.</p></li><li><p>数字格式化代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数字格式化</span><br><span class="line"> *</span><br><span class="line"> * @export</span><br><span class="line"> * @param &#123;any&#125; number 要格式化的数字</span><br><span class="line"> * @param &#123;any&#125; decimals 保留几位小数</span><br><span class="line"> * @param &#123;any&#125; decPoint 小数点符号</span><br><span class="line"> * @param &#123;any&#125; thousandsSep 千分位符号</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">export function numberFormat (number, decimals, decPoint, thousandsSep) &#123;</span><br><span class="line">  number = (number + &apos;&apos;).replace(/[^0-9+-Ee.]/g, &apos;&apos;);</span><br><span class="line">  let n = !isFinite(+number) ? 0 : +number;</span><br><span class="line">  let prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);</span><br><span class="line">  let sep = typeof thousandsSep === &apos;undefined&apos; ? &apos;,&apos; : thousandsSep;</span><br><span class="line">  let dec = typeof decPoint === &apos;undefined&apos; ? &apos;.&apos; : decPoint;</span><br><span class="line">  let s = &apos;&apos;;</span><br><span class="line">  let toFixedFix = function (n, prec) &#123;</span><br><span class="line">    let k = Math.pow(10, prec);</span><br><span class="line">    return &apos;&apos; + Math.ceil(n * k) / k;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  s = (prec ? toFixedFix(n, prec) : &apos;&apos; + Math.round(n)).split(&apos;.&apos;);</span><br><span class="line">  let re = /(-?\d+)(\d&#123;3&#125;)/;</span><br><span class="line">  while (re.test(s[0])) &#123;</span><br><span class="line">    s[0] = s[0].replace(re, &apos;$1&apos; + sep + &apos;$2&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((s[1] || &apos;&apos;).length &lt; prec) &#123;</span><br><span class="line">    s[1] = s[1] || &apos;&apos;;</span><br><span class="line">    s[1] += new Array(prec - s[1].length + 1).join(&apos;0&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  return s.join(dec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字格式化代码解析：（个人理解）</p><p>​    1.<strong>number+””</strong>将number这个变量铁定变为字符串方便使用replace()函数</p><p>​    2.[/[^0-9+-Ee.]/g]这个正则全局匹配0-9以及E和e，以及数字的正负</p><p>​    3.isFinite()函数判断其是否为有限数值，不是有限数值就为0，是则为+number</p><p>​    4.Math.abs()取绝对值，Math.pow()幂指数，Math.round()四舍五入</p><p>​    5.千分位符号，我特地查了下。。。<strong>千分位形式,即从个位数起,每三位之间加一个逗号,例如,将7654321输出成7,654,321。</strong></p><p>​    6.toFIxedFix函数里，先让k=10^pre;Math.ceil(n*k)/k，保留几位小数与Math.round()后面的区别是当prec存在可以计算数据，不存在返回Math.round()后面数据</p><p>​    7.s=…..split(“,”);得到s为整数部分， let re = /(-?\d+)(\d{3})/;匹配正整数或负整数：比如有负整数-1234，那么\$1-1，\$2=234，-1234567，那么$1=-1234，$2=567。（这句代码还挺难嚼得）</p><p>​    8.s[1]的长度小于prec时就会加0，.join(“0”)同样巧用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React-router4.0的坑</title>
      <link href="/2018/10/31/React-router4.0/"/>
      <url>/2018/10/31/React-router4.0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="React-router4-0的坑"><a href="#React-router4-0的坑" class="headerlink" title="React-router4.0的坑"></a>React-router4.0的坑</h3><p>许久不用react，结果今天上来写个demo，瞬间就在router上挂住了。</p><blockquote><p>​    原先的router去掉了，换成（类似redux的provider）BrowserRouter包裹整个项目</p><p>​    like:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render( &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure><blockquote><p>​    然后我突然间发现我的二级路由的component并没有显示，于是我再次请求文档，发现自己在“/”路由下写了个exact，exact关键字，这个关键字是将”/“做唯一匹配，否则”/“和”/xxx”都会匹配到path为”/“的路由，制定exact后，”/page1”就不会再匹配到”/“了。不明白的话，可以动手按照我的路由试试。</p></blockquote><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route exact path=&quot;/&quot;&gt;</span><br><span class="line">  &lt;Route path=&quot;/home&quot; component=&#123;home&#125;/ &gt;</span><br><span class="line">        &#123;/* &lt;Route path=&quot;&quot;&gt;&lt;/Route&gt; */&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>好了，终于按照我的要求出来了！</p><p>于是乎我又去了解了下BrowserRouter又发现了一片新天地：</p><blockquote><p>​    BrowserRouter、HashRouter、MemoryRouter这三类不同的router，react为什么要分三类呢？</p><p>之前的history分为以下三类：</p><ul><li>hashHistory 老版本浏览器的history</li><li>browserHistory h5的history</li><li>memoryHistory node环境下的history，存储在memory中</li></ul><p>4.0之前版本的react-router针对三者分别实现了createHashHistory、createBrowserHistory和create MemoryHistory三个方法来创建三种情况下的history</p></blockquote><p>今天就到这儿吧！晚安~</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>真实dom</title>
      <link href="/2018/10/31/truely-dom/"/>
      <url>/2018/10/31/truely-dom/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="真实dom"><a href="#真实dom" class="headerlink" title="真实dom"></a>真实dom</h4><blockquote><p>​    e.target|ref,找到真实dom</p></blockquote><h4 id="同异步关系"><a href="#同异步关系" class="headerlink" title="同异步关系"></a>同异步关系</h4><blockquote><p>setState({})异步，console.log()同步不能输出真实dom个数，setState(()=&gt;{</p><p>console.log(获取dom)；</p><p>(return)</p><p>})</p></blockquote><h3 id="componentwillrecieveprops"><a href="#componentwillrecieveprops" class="headerlink" title="componentwillrecieveprops"></a>componentwillrecieveprops</h3><blockquote><p>​    1、        从父组件接收参数</p><p>​    2、        第一次添加父组件中不执行此生命周期</p><p>​    3、        其余更新</p></blockquote><h4 id="componentwillUnmount"><a href="#componentwillUnmount" class="headerlink" title="componentwillUnmount"></a>componentwillUnmount</h4><blockquote><p>​        子组件移除之前瞬间</p></blockquote><h4 id="动画—-gt-transition-group"><a href="#动画—-gt-transition-group" class="headerlink" title="动画—&gt;transition group"></a>动画—&gt;transition group</h4><blockquote><p>className=”fade”</p><p>入场:1、fade-enter</p><p>​    2、fade-enter-active</p><p>​    3、fade-enter-done</p><p>出场 1、fade-exit</p><p>​    2、fade-exit-active</p><p>​    3、fade-exit-done</p><p>unmountOnExitonEntered((el)=&gt;{</p><p>​    el.style.color=…</p><p>})</p><p>apear={Boolean}</p><p>fade-appear |fade-appear-active</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>狠</title>
      <link href="/2018/10/25/casual-literator/"/>
      <url>/2018/10/25/casual-literator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>​    今日和高中好友偶然谈起“做人是否应该狠？”，想着昨日创建的博客，便作此文。</p><p>​    我自己本就是一个优柔寡断之人，爱受影响。听着好友’人不狠不稳‘，我刚开始确实不敢苟同。在我的象牙塔里，人生奋斗是理所当然的会过上好生活，’好人占多数‘那些鸡汤般语言充斥着我的耳根。且不说这些话的正确与否，我坚持的是自己那颗本心&gt;即善良只为心安。可当”人不为己天诛地灭“等这些利己主义的话语在我脑海里徜徉时，我又不得不思考自己的人生究竟该怎么去过。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>​    下面我将从感情、工作和做人三方面说明我对狠的理解。</p><p>​    “似她红衣灼灼,白沙大漠绽出曼陀罗。回忆,都斑驳,谁还记得,曾经的许诺”，情殇从古至今都是如此得令人感动与伤感。我也曾像很多人那样，追求所谓的爱情，殊不知，一直活在自己的世界里，连爱的人都是虚幻的。伤过一次又一次，渐渐的开始认清自己所处的世界没有完美，自己也并不完美。白雪公主永远只在童话世界里陪伴着小孩子。而我们终将被世界现实打磨得理性，充斥着主宰生活与被生活主宰的循环中。而这也是我对狠的理解，“抛弃那些天真烂漫的喜欢，回归历经沧桑后的相濡以沫”。历经沧桑的相濡以沫或许在某些人眼中正是爱情，但对我来说这就是狠，狠下心来对待周遭的异性荷尔蒙的诱惑，狠下心来对待自己一颗躁动的内心。</p><p>​    浮躁的心是干不了任何事情的，工作需要的是一颗冷静而不失火热的内心。有这种欲望，才会狠。狠字扮演着的便是做事中，不对自己留有余地，一件事情要么不做，要么不顾一切的做好。说这些话容易，做起来就像当局者迷般迷惘。狠字还要“果敢”，果断勇敢不怕失败，狠起来做事如狼似虎。</p><p>​    最难阐述的或许应该是做人吧，22岁的我，并没有太多人生阅历，但是要说到为不狠买单，我干了不少事。如果当初我当时权衡自己的利益和别人的利益，我果断不会考虑他人利益损害自己。（涉及到一些隐私）虽说中国是人情社会，但是利益永远至上，我想这句话大家没意见吧，如果有人为了情谊放弃利益，那就是利益不够。而且这种趋向越来越明显。做人狠，不是不善良，保持善良确实应该提倡，可是在社会中又有多少人会为你的善良买单，别总妄想着善良就会有人帮，这就是我朋友所说的“人不狠不稳”，你要一直妄想着靠你的善良依靠别人为你的事情买单，那是做梦。每个人都会为了自己而考虑这件事情，很少会有人冒着生命危险去救你这个不相干的人的命。所以，做人嘛，得狠起来，狠了才能立，立了方能直，直了才能有其他。</p><p>​    总结：狠，就是对办事的积极高效，就是对感情的忠贞，对生活，对做人的一种态度。</p><p>ps：我是个对生活、学习、工作、感情总是犹犹豫豫，做的事永远拖泥带水，希望在以后能做一个狠人吧。</p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6及ES6+</title>
      <link href="/2018/10/25/js-answer/"/>
      <url>/2018/10/25/js-answer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ES6及ES6"><a href="#ES6及ES6" class="headerlink" title="ES6及ES6+"></a>ES6及ES6+</h1><h3 id="…args-的用途"><a href="#…args-的用途" class="headerlink" title="[…args]的用途"></a>[…args]的用途</h3><blockquote><ol><li><p>函数声明时使用</p><p>“栗子”：<code>function add([...args]){...}</code></p></li><li><p>收集成数组</p><p>“栗子”：<code>var arr=[1,2,3]</code></p><p>​        <code>function arr_push(){</code></p><p>​            <code>arr.push(4);</code></p><p>​            <code>console.log([...arr])</code>    </p><p>​        <code>//控制台打印出[1,2,3,4]</code>            </p><p>​            <code>}</code></p></li></ol></blockquote><h3 id="对象属性赋值省略的机制"><a href="#对象属性赋值省略的机制" class="headerlink" title="对象属性赋值省略的机制"></a>对象属性赋值省略的机制</h3><blockquote><p>​    由测试可知并不是省略了<code>{x:x}</code>中的<code>:x</code></p><p>​    而是省略了<code>x:</code></p></blockquote><h3 id="object-assign复制对象"><a href="#object-assign复制对象" class="headerlink" title="object.assign复制对象"></a>object.assign复制对象</h3><blockquote><p>​    浅操作，只能复制对象的引用</p><p>​    深拷贝可用JSON下的对象，<code>json.parse(json.stringify(obj))</code></p></blockquote><h6 id="函数简洁表示方法"><a href="#函数简洁表示方法" class="headerlink" title="函数简洁表示方法"></a>函数简洁表示方法</h6><blockquote><p>​    <code>foo:function(){}</code>可表示为<code>foo(){}</code></p><p>​    注：<em>super只能在简洁方法中出现</em></p><p>​        <em>数组深拷贝两种方法：1、<code>arr.slice(0)</code>2、<code>let newArr=arr.concat()</code></em></p></blockquote><p>###JS中基础数据类型&amp;复杂数据类型</p><blockquote><ul><li><p><strong>字符串 数值 布尔类型 null undefined</strong> </p></li><li><p><strong>对象 数组 正则 函数 Map Set</strong></p><p>注：<em>JS中，从变量的存储来看，分为两个地方，栈内存和堆内存。基础数据都存在栈内存</em></p></li></ul></blockquote><h6 id="symbol的妙用"><a href="#symbol的妙用" class="headerlink" title="symbol的妙用"></a>symbol的妙用</h6><blockquote><p>​    <code>symbol.for</code>    看是否存在常量，存在返回此常量，不存在创建此常量    </p><p>​    <code>[symbol.iterator]()</code>创建全新迭代器</p><p><em>当你为对象添加 <code>myObject.toString()</code>方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加 <code>myObject[Symbol.iterator]()</code>方法，就可以用<code>for of</code>遍历这个对象了。</em></p></blockquote><p>###生成器与迭代器的区别</p><blockquote><p>​    生成器包含一个或者多个yeild</p><p>​    迭代器只要是一个iterator就行</p><p><em>问题来了：什么是iterator？名词解释：遍历器，简而言之拥有next方法和done方法的可遍历对象</em></p></blockquote><h3 id="class中的一些禁忌"><a href="#class中的一些禁忌" class="headerlink" title="class中的一些禁忌"></a>class中的一些禁忌</h3><blockquote><ol><li><p>Q:子构造器this应当怎样使用？    </p><p>A:必须先用super，特别在框架中如此使用的时候</p><p>R:创建和初始化是在父构造器中实现的</p></li><li><p>Q：static能在new出来的函数对象中使用吗？</p><p>A：不能</p><p>R：只能定义在class类的函数对象中</p></li></ol></blockquote><h3 id="比较-0和-0"><a href="#比较-0和-0" class="headerlink" title="比较+0和-0"></a>比较+0和-0</h3><blockquote><p>​    ===并不能严格比较+0和-0</p><p>​    应用object.is，<strong>一般情况下用===，性能最高</strong></p><p>​    object.has与object.is方法大致相同，只是不能区分+0和-0，</p><p>​    判断数字用<code>Number.isNaN()</code></p></blockquote><h3 id="数组新增方法"><a href="#数组新增方法" class="headerlink" title="数组新增方法"></a>数组新增方法</h3><blockquote><ol><li><p>Array.from把类数组变为一个真数组</p></li><li><p><code>Array.of(1，2，3，4)</code>把参数1-4变为一个数组</p></li><li><p><code>Array.copyWithin(idx,start,end)</code>从右往左覆盖    ?</p></li><li><p>find/findIndex </p><p>find返回数组中第一个符合条件的元素, findIndex返回索引</p></li><li><p>fill</p><ul><li>数组中的每一个值替换</li><li>范围替换 (val,start,end)</li><li>扩展 [].fill.call({length:3},4);返回<strong>对象</strong>，全是4</li></ul></li><li><p>includes返回boolean值</p></li></ol></blockquote><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><blockquote><p>​    Define:理解为在一个函数内部的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><p>​    自我理解：一个函数a的内部函数b引用上一层函数的变量i，此函数a返回内部函数b，然后此函数a用外部变量接收，即var c = a()相当于c=function b(){};最后执行c();相当于调用b。</p><p>​    作用：1、本来一个局部函数的局部变量只能由他子层函数使用，现在调用到外部来使用</p><p>​            2、隐藏数据，从而保护数据的隐秘性和提高其安全性</p><p>​            3、在内存中维持一个变量，从而实现变量的全局可操作性，例如框架中的cache缓存就必须用到闭包等等。</p></blockquote><h3 id="Vue中使用sort排序进行过滤时出现以下警告"><a href="#Vue中使用sort排序进行过滤时出现以下警告" class="headerlink" title="Vue中使用sort排序进行过滤时出现以下警告"></a>Vue中使用sort排序进行过滤时出现以下警告</h3><blockquote><p>​    array.sort()会计算这个数组本身，会导致filter重新应用，通过复制数组来排序就不会影响原数组重新触发filter过滤器，新数组改变，最后赋值给filter就能达到效果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
