<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2019/01/02/vue-router/"/>
      <url>/2019/01/02/vue-router/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###vue-router的路由守卫的钩子函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照顺序的钩子函数</span><br><span class="line">beforeEach(to,from,next)&#123;&#125;,//全局</span><br><span class="line">beforeEnter(to,from,next)&#123;&#125;,//路由里面定义</span><br><span class="line">beforeRouteEach(to,from,next)&#123;&#125;,//组件</span><br><span class="line">beforeResolve(to,from,next)&#123;&#125;,//全局</span><br><span class="line">afterEach(to,from)&#123;&#125;//全局</span><br></pre></td></tr></table></figure><h3 id="额外的钩子函数"><a href="#额外的钩子函数" class="headerlink" title="额外的钩子函数"></a>额外的钩子函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate(to,from,next)&#123;&#125;,//组件</span><br><span class="line">beforeRouteLeave(to,from,next)&#123;&#125;//组件</span><br></pre></td></tr></table></figure><p>next()中可为next(“/“)或者next({path:”/“})</p><h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p>定义路由的时候可以配置meta字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta:&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>可使路由缓存，从而保存数据。上面的meta中可设置keep-alive定义其缓存与否。</p><h3 id="import优化性能"><a href="#import优化性能" class="headerlink" title="import优化性能"></a>import优化性能</h3><p>路由懒加载，需下载syntax-dynamic-import插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const _import_ = file =&gt; () =&gt; import(&apos;@/views/&apos; + file + &apos;.vue&apos;)</span><br></pre></td></tr></table></figure><h3 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h3><p>​    一般用以下代码滚动行为不会影响下一个路由</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">&gt;   <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> savedPosition</span><br><span class="line">&gt;   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><blockquote><p>to.params.id,from.params.id….</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>移动端项目总结</title>
      <link href="/2018/11/27/yidongduan/"/>
      <url>/2018/11/27/yidongduan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面说一些我在写移动端项目时总结的经验：</p><ul><li>我们知道移动端click点击事件有300s延迟，为了正常使用click，需引入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在main.js编写如下代码：</span><br></pre></td></tr></table></figure></li></ul><p>import fastClick from ‘fastclick’<br>fastClick.attach(document.body)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 低版本安卓浏览器打开一片白</span><br></pre></td></tr></table></figure></p><p>import ‘babel-polyfill’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 轮播图、横向滑动tab、图片放大滑动等这些使用```vue-awesome-swiper```插件</span><br></pre></td></tr></table></figure></p><p>import VueAwesomeSwiper from ‘vue-awesome-swiper’<br>import ‘swiper/dist/css/swiper.css’<br>Vue.use(VueAwesomeSwiper)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">具体使用场景需参照文档配置```option```选项，这里不再赘述。</span><br><span class="line">下面只阐述一点就是我们在使用插件时常常需要更改样式，比如改变轮播图下面小圆点的颜色。这里我们推荐使用**样式穿透**：</span><br><span class="line">  ```/deep/ ```是```sass```和```less```的样式穿透</span><br><span class="line">  ```&gt;&gt;&gt;```是```stylus```的样式穿透</span><br></pre></td></tr></table></figure></p><p> .wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active<br>    background: #fff<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">.wrapper  /deep/ .swiper-pagination-bullet-active &#123;</span><br><span class="line">    background: #fff</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>当我们要引入不是其本文件跟目录下的 css 文件时，记得使用<figure class="highlight plain"><figcaption><span>```来简化``` './../../....'```这些相对路径。或者使用```'~路径别名'```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">@import &apos;./../../../assets/css/mixin.scss&apos;;</span><br><span class="line">//简化成功</span><br><span class="line">@import &apos;~@/assets/css/mixin.scss&apos;;</span><br><span class="line">@import &apos;~styles/varibles.scss&apos;</span><br></pre></td></tr></table></figure></p></li><li><p>css常用相同模块内容可以提mixin提供多处使用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin omit &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后通过<code>@include</code>来调用具有相同名称的mixin模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">　@include omit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>在css里面，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 可以进行提前占位，避免资源加载时候的闪烁</span><br><span class="line">2. 还可以让高度自适应</span><br><span class="line">在移动端或者在响应式开发情况下，我们可以利用这个特性来实现图片等比例缩放自适应。</span><br><span class="line">解决核心思想为：提供一个容器，设置容器的高度为0，再设置padding-bottom为56.25%（需要自适应的元素高度除以宽度*100%）（因为padding的百分比是按照容器宽度计算的，所以由padding来撑开容器高度，而不是height，保证了容器的宽高比例）</span><br></pre></td></tr></table></figure></li></ul><div class="wrapper"><br>  <img class="swiper-img"><br></div><p>.wrapper {<br>    overflow: hidden<br>    width: 100%<br>    height: 0<br>    padding-bottom: 31.25%<br>}<br>.swiper-img {<br>    width: 100%<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  移动端页面当滑动到底部时，路由跳转后发现页面还是保持在底部，这里可以在router中配置</span><br></pre></td></tr></table></figure></p><p>scrollBehavior (to, from, savedPosition) {<br>    return { x: 0, y: 0 }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 项目打包后，manifest.js可以理解为webpack打包生成的配置文件， vendor.js各个页面各个组件公用的一些代码，app.js放的是项目各个页面的业务逻辑代码。**app.js至少超过1M的时候才使用异步组件**</span><br><span class="line">* 使用keep-alive时有两个钩子函数:</span><br><span class="line">![877cd98ea39d2dcdce0918a0d9073d6.png](https://upload-images.jianshu.io/upload_images/5120924-9c48bbd34ef6b3e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure></p><p>mounted () {<br>    this.lastCity = this.city<br>    this.getHomeInfo()   //ajax请求<br>  },<br>  activated () {<br>    if (this.lastCity !== this.city) {<br>      this.lastCity = this.city<br>      this.getHomeInfo()<br>    }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 有一个移动端很常见的效果，当滑动右边部分的时候，左边会联动显示与当前内容相符合的标题高亮，当点击左边某一个标题的时候，右边会自动滑动到相应的内容。**左右联动效果**，可以通过```better-scroll```这个插件实现。另外，**横向滚动的导航栏**、**竖向滚动的列表**都可以通过这个插件来实现。</span><br></pre></td></tr></table></figure></p><p><template><br>    <!--定义外层--><br>    <div class="wrapper" ref="wrapper"><br>        <!--定义需要滚动的内容区域--><br>        <ul class="content"><br>            <li v-for="item in items"></li><br>        </ul><br>    </div><br></template></p><p><script><br>  import BScroll from ‘better-scroll’<br>  export default {<br>    mounted() {<br>      this.$nextTick(() =&gt; {<br>        this.scroll = new Bscroll(this.$refs.wrapper, {})<br>      })<br>    },<br>   watch: {<br>     letter () {<br>       if (this.letter) {<br>        const element = this.$refs[this.letter][0]<br>        this.scroll.scrollToElement(element)<br>      }<br>    }<br>   },<br>  }<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">样式这里需要注意的是，要滚动的这一部分给了固定的高度，且超出部分```overflow:hidden;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">    overflow: hidden</span><br><span class="line">    position: absolute</span><br><span class="line">    top: 1.58rem</span><br><span class="line">    left: 0</span><br><span class="line">    right: 0</span><br><span class="line">    bottom: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外附上better-scroll原作者的文章：<a href="https://www.imooc.com/article/18232" target="_blank" rel="noopener">https://www.imooc.com/article/18232</a></p><ul><li>我们做好的项目，如何在移动端进行调试呢？<br>我们发现，vue项目是用webpack-dev-server这个服务器跑起来的，这个服务器默认外部是无法访问的，需在package.json中加入<figure class="highlight plain"><figcaption><span>0.0.0.0```才行：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更改后的配置如下：</span><br></pre></td></tr></table></figure></li></ul><p>“scripts”: {<br>    “dev”: “webpack-dev-server –host 0.0.0.0 –inline –progress –config build/webpack.dev.conf.js”,<br>  },<br><code>这样的话，在命令行运行</code> ipconfig<code>`</code>，手机和电脑连接同一局域网，用手机访问电脑的ip地址就可以用真机打开啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> 移动端,Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hybrid初探</title>
      <link href="/2018/11/08/hybrid-first/"/>
      <url>/2018/11/08/hybrid-first/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="hybrid实现"><a href="#hybrid实现" class="headerlink" title="hybrid实现"></a>hybrid实现</h3><blockquote><p>​    即客户端与前端和服务器三端的结合</p><p>​    hybrid混合开发app的应用的客户端即是所搭的框架，前端即是app的页面内容，服务器端即是保存和管理前端静态页的server上传等。</p><h5 id="怎么更改app的内容即前端部分？"><a href="#怎么更改app的内容即前端部分？" class="headerlink" title="怎么更改app的内容即前端部分？"></a>怎么更改app的内容即前端部分？</h5><p>答：通过自定义的版本号来定其是否应该更新</p><h5 id="为什么要用hybird而不用H5？"><a href="#为什么要用hybird而不用H5？" class="headerlink" title="为什么要用hybird而不用H5？"></a>为什么要用hybird而不用H5？</h5><p>答：1.hybird是通过file协议，而h5是通过https协议。file协议相对于http协议更快。</p><p>2.更新迭代速度更快</p></blockquote><p>体验虽然抵不上NA，但是上述两点有点足以让很多app都用hybrid，一般肉眼也看不清。</p>]]></content>
      
      
      <categories>
          
          <category> hybrid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hybrid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React视频观看总结</title>
      <link href="/2018/11/08/React-video-collect/"/>
      <url>/2018/11/08/React-video-collect/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>React是组件化的，而Vue是模板与js分离更彻底。</p><p>React用的是JSX标准（JSX为语法糖，需要被解析成js才能在浏览器中运行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">React: React.createElement(&quot;div&quot;,&#123;key:value&#125;,[...])</span><br><span class="line">Vue: h(&quot;div&quot;,onClick&#123;&#125;...) //代码即为VUE和React的生成虚拟dom的代码.</span><br></pre></td></tr></table></figure><p>React中的patch函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(container,...)这段代码将第一次执行patch函数，即patch(container,vnode),</span><br><span class="line">setState(&#123;...&#125;)这段代码将第二次执行patch函数，即patch(vnode,newVode)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(&#123;..&#125;)与vue的this....修改属性同样都是异步</span><br></pre></td></tr></table></figure><h3 id="为什么要是异步："><a href="#为什么要是异步：" class="headerlink" title="为什么要是异步："></a>为什么要是异步：</h3><blockquote><ol><li>函数是要给外界众多人用的，可以改变多次，用异步更优化性能</li><li>同名属性的修改不用向用户展示过程，只用展示结果</li></ol></blockquote><h3 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h3><blockquote><ol><li>组件的封装</li><li>组件的复用</li></ol></blockquote><h3 id="React与VUE的技术选型"><a href="#React与VUE的技术选型" class="headerlink" title="React与VUE的技术选型"></a>React与VUE的技术选型</h3><blockquote><ol><li>Vue更适合模板与js分离，React更适合组件化</li><li>Vue更适合小中型公司，学习成本相对不高，并且拿来直接用，生态圈也广，并且适合国内发展（个人理解）</li><li>React更适合大型公司的组件化开发，更适合复用</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数字格式化代码的详细解析</title>
      <link href="/2018/11/04/number/"/>
      <url>/2018/11/04/number/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###vue小技巧总结：</p><ol><li><p>~：图片、CSS变模块引入</p></li><li><p>@：src目录下</p></li><li><p>/** enter键：生成函数的参数、返回值以及对应的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建请求</span><br><span class="line"> * @param &#123;string&#125; URL 请求地址</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li><li><p>大佬一般将文件放一个index和其他的命名moduels，index负责导出这些命名的moduels.</p></li><li><p>数字格式化代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数字格式化</span><br><span class="line"> *</span><br><span class="line"> * @export</span><br><span class="line"> * @param &#123;any&#125; number 要格式化的数字</span><br><span class="line"> * @param &#123;any&#125; decimals 保留几位小数</span><br><span class="line"> * @param &#123;any&#125; decPoint 小数点符号</span><br><span class="line"> * @param &#123;any&#125; thousandsSep 千分位符号</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">export function numberFormat (number, decimals, decPoint, thousandsSep) &#123;</span><br><span class="line">  number = (number + &apos;&apos;).replace(/[^0-9+-Ee.]/g, &apos;&apos;);</span><br><span class="line">  let n = !isFinite(+number) ? 0 : +number;</span><br><span class="line">  let prec = !isFinite(+decimals) ? 0 : Math.abs(decimals);</span><br><span class="line">  let sep = typeof thousandsSep === &apos;undefined&apos; ? &apos;,&apos; : thousandsSep;</span><br><span class="line">  let dec = typeof decPoint === &apos;undefined&apos; ? &apos;.&apos; : decPoint;</span><br><span class="line">  let s = &apos;&apos;;</span><br><span class="line">  let toFixedFix = function (n, prec) &#123;</span><br><span class="line">    let k = Math.pow(10, prec);</span><br><span class="line">    return &apos;&apos; + Math.ceil(n * k) / k;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  s = (prec ? toFixedFix(n, prec) : &apos;&apos; + Math.round(n)).split(&apos;.&apos;);</span><br><span class="line">  let re = /(-?\d+)(\d&#123;3&#125;)/;</span><br><span class="line">  while (re.test(s[0])) &#123;</span><br><span class="line">    s[0] = s[0].replace(re, &apos;$1&apos; + sep + &apos;$2&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ((s[1] || &apos;&apos;).length &lt; prec) &#123;</span><br><span class="line">    s[1] = s[1] || &apos;&apos;;</span><br><span class="line">    s[1] += new Array(prec - s[1].length + 1).join(&apos;0&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  return s.join(dec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字格式化代码解析：（个人理解）</p><p>​    1.<strong>number+””</strong>将number这个变量铁定变为字符串方便使用replace()函数</p><p>​    2.[/[^0-9+-Ee.]/g]这个正则全局匹配0-9以及E和e，以及数字的正负</p><p>​    3.isFinite()函数判断其是否为有限数值，不是有限数值就为0，是则为+number</p><p>​    4.Math.abs()取绝对值，Math.pow()幂指数，Math.round()四舍五入</p><p>​    5.千分位符号，我特地查了下。。。<strong>千分位形式,即从个位数起,每三位之间加一个逗号,例如,将7654321输出成7,654,321。</strong></p><p>​    6.toFIxedFix函数里，先让k=10^pre;Math.ceil(n*k)/k，保留几位小数与Math.round()后面的区别是当prec存在可以计算数据，不存在返回Math.round()后面数据</p><p>​    7.s=…..split(“,”);得到s为整数部分， let re = /(-?\d+)(\d{3})/;匹配正整数或负整数：比如有负整数-1234，那么\$1-1，\$2=234，-1234567，那么$1=-1234，$2=567。（这句代码还挺难嚼得）</p><p>​    8.s[1]的长度小于prec时就会加0，.join(“0”)同样巧用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React-router4.0的坑</title>
      <link href="/2018/10/31/React-router4.0/"/>
      <url>/2018/10/31/React-router4.0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="React-router4-0的坑"><a href="#React-router4-0的坑" class="headerlink" title="React-router4.0的坑"></a>React-router4.0的坑</h3><p>许久不用react，结果今天上来写个demo，瞬间就在router上挂住了。</p><blockquote><p>​    原先的router去掉了，换成（类似redux的provider）BrowserRouter包裹整个项目</p><p>​    like:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render( &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure><blockquote><p>​    然后我突然间发现我的二级路由的component并没有显示，于是我再次请求文档，发现自己在“/”路由下写了个exact，exact关键字，这个关键字是将”/“做唯一匹配，否则”/“和”/xxx”都会匹配到path为”/“的路由，制定exact后，”/page1”就不会再匹配到”/“了。不明白的话，可以动手按照我的路由试试。</p></blockquote><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route exact path=&quot;/&quot;&gt;</span><br><span class="line">  &lt;Route path=&quot;/home&quot; component=&#123;home&#125;/ &gt;</span><br><span class="line">        &#123;/* &lt;Route path=&quot;&quot;&gt;&lt;/Route&gt; */&#125;</span><br><span class="line">&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>好了，终于按照我的要求出来了！</p><p>于是乎我又去了解了下BrowserRouter又发现了一片新天地：</p><blockquote><p>​    BrowserRouter、HashRouter、MemoryRouter这三类不同的router，react为什么要分三类呢？</p><p>之前的history分为以下三类：</p><ul><li>hashHistory 老版本浏览器的history</li><li>browserHistory h5的history</li><li>memoryHistory node环境下的history，存储在memory中</li></ul><p>4.0之前版本的react-router针对三者分别实现了createHashHistory、createBrowserHistory和create MemoryHistory三个方法来创建三种情况下的history</p></blockquote><p>今天就到这儿吧！晚安~</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React.js </tag>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>真实dom</title>
      <link href="/2018/10/31/truely-dom/"/>
      <url>/2018/10/31/truely-dom/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="真实dom"><a href="#真实dom" class="headerlink" title="真实dom"></a>真实dom</h4><blockquote><p>​    e.target|ref,找到真实dom</p></blockquote><h4 id="同异步关系"><a href="#同异步关系" class="headerlink" title="同异步关系"></a>同异步关系</h4><blockquote><p>setState({})异步，console.log()同步不能输出真实dom个数，setState(()=&gt;{</p><p>console.log(获取dom)；</p><p>(return)</p><p>})</p></blockquote><h3 id="componentwillrecieveprops"><a href="#componentwillrecieveprops" class="headerlink" title="componentwillrecieveprops"></a>componentwillrecieveprops</h3><blockquote><p>​    1、        从父组件接收参数</p><p>​    2、        第一次添加父组件中不执行此生命周期</p><p>​    3、        其余更新</p></blockquote><h4 id="componentwillUnmount"><a href="#componentwillUnmount" class="headerlink" title="componentwillUnmount"></a>componentwillUnmount</h4><blockquote><p>​        子组件移除之前瞬间</p></blockquote><h4 id="动画—-gt-transition-group"><a href="#动画—-gt-transition-group" class="headerlink" title="动画—&gt;transition group"></a>动画—&gt;transition group</h4><blockquote><p>className=”fade”</p><p>入场:1、fade-enter</p><p>​    2、fade-enter-active</p><p>​    3、fade-enter-done</p><p>出场 1、fade-exit</p><p>​    2、fade-exit-active</p><p>​    3、fade-exit-done</p><p>unmountOnExitonEntered((el)=&gt;{</p><p>​    el.style.color=…</p><p>})</p><p>apear={Boolean}</p><p>fade-appear |fade-appear-active</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>狠</title>
      <link href="/2018/10/25/casual-literator/"/>
      <url>/2018/10/25/casual-literator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>​    今日和高中好友偶然谈起“做人是否应该狠？”，想着昨日创建的博客，便作此文。</p><p>​    我自己本就是一个优柔寡断之人，爱受影响。听着好友’人不狠不稳‘，我刚开始确实不敢苟同。在我的象牙塔里，人生奋斗是理所当然的会过上好生活，’好人占多数‘那些鸡汤般语言充斥着我的耳根。且不说这些话的正确与否，我坚持的是自己那颗本心&gt;即善良只为心安。可当”人不为己天诛地灭“等这些利己主义的话语在我脑海里徜徉时，我又不得不思考自己的人生究竟该怎么去过。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>​    下面我将从感情、工作和做人三方面说明我对狠的理解。</p><p>​    “似她红衣灼灼,白沙大漠绽出曼陀罗。回忆,都斑驳,谁还记得,曾经的许诺”，情殇从古至今都是如此得令人感动与伤感。我也曾像很多人那样，追求所谓的爱情，殊不知，一直活在自己的世界里，连爱的人都是虚幻的。伤过一次又一次，渐渐的开始认清自己所处的世界没有完美，自己也并不完美。白雪公主永远只在童话世界里陪伴着小孩子。而我们终将被世界现实打磨得理性，充斥着主宰生活与被生活主宰的循环中。而这也是我对狠的理解，“抛弃那些天真烂漫的喜欢，回归历经沧桑后的相濡以沫”。历经沧桑的相濡以沫或许在某些人眼中正是爱情，但对我来说这就是狠，狠下心来对待周遭的异性荷尔蒙的诱惑，狠下心来对待自己一颗躁动的内心。</p><p>​    浮躁的心是干不了任何事情的，工作需要的是一颗冷静而不失火热的内心。有这种欲望，才会狠。狠字扮演着的便是做事中，不对自己留有余地，一件事情要么不做，要么不顾一切的做好。说这些话容易，做起来就像当局者迷般迷惘。狠字还要“果敢”，果断勇敢不怕失败，狠起来做事如狼似虎。</p><p>​    最难阐述的或许应该是做人吧，22岁的我，并没有太多人生阅历，但是要说到为不狠买单，我干了不少事。如果当初我当时权衡自己的利益和别人的利益，我果断不会考虑他人利益损害自己。（涉及到一些隐私）虽说中国是人情社会，但是利益永远至上，我想这句话大家没意见吧，如果有人为了情谊放弃利益，那就是利益不够。而且这种趋向越来越明显。做人狠，不是不善良，保持善良确实应该提倡，可是在社会中又有多少人会为你的善良买单，别总妄想着善良就会有人帮，这就是我朋友所说的“人不狠不稳”，你要一直妄想着靠你的善良依靠别人为你的事情买单，那是做梦。每个人都会为了自己而考虑这件事情，很少会有人冒着生命危险去救你这个不相干的人的命。所以，做人嘛，得狠起来，狠了才能立，立了方能直，直了才能有其他。</p><p>​    总结：狠，就是对办事的积极高效，就是对感情的忠贞，对生活，对做人的一种态度。</p><p>ps：我是个对生活、学习、工作、感情总是犹犹豫豫，做的事永远拖泥带水，希望在以后能做一个狠人吧。</p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6及ES6+</title>
      <link href="/2018/10/25/js-answer/"/>
      <url>/2018/10/25/js-answer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ES6及ES6"><a href="#ES6及ES6" class="headerlink" title="ES6及ES6+"></a>ES6及ES6+</h1><h3 id="…args-的用途"><a href="#…args-的用途" class="headerlink" title="[…args]的用途"></a>[…args]的用途</h3><blockquote><ol><li><p>函数声明时使用</p><p>“栗子”：<code>function add([...args]){...}</code></p></li><li><p>收集成数组</p><p>“栗子”：<code>var arr=[1,2,3]</code></p><p>​        <code>function arr_push(){</code></p><p>​            <code>arr.push(4);</code></p><p>​            <code>console.log([...arr])</code>    </p><p>​        <code>//控制台打印出[1,2,3,4]</code>            </p><p>​            <code>}</code></p></li></ol></blockquote><h3 id="对象属性赋值省略的机制"><a href="#对象属性赋值省略的机制" class="headerlink" title="对象属性赋值省略的机制"></a>对象属性赋值省略的机制</h3><blockquote><p>​    由测试可知并不是省略了<code>{x:x}</code>中的<code>:x</code></p><p>​    而是省略了<code>x:</code></p></blockquote><h3 id="object-assign复制对象"><a href="#object-assign复制对象" class="headerlink" title="object.assign复制对象"></a>object.assign复制对象</h3><blockquote><p>​    浅操作，只能复制对象的引用</p><p>​    深拷贝可用JSON下的对象，<code>json.parse(json.stringify(obj))</code></p></blockquote><h6 id="函数简洁表示方法"><a href="#函数简洁表示方法" class="headerlink" title="函数简洁表示方法"></a>函数简洁表示方法</h6><blockquote><p>​    <code>foo:function(){}</code>可表示为<code>foo(){}</code></p><p>​    注：<em>super只能在简洁方法中出现</em></p><p>​        <em>数组深拷贝两种方法：1、<code>arr.slice(0)</code>2、<code>let newArr=arr.concat()</code></em></p></blockquote><p>###JS中基础数据类型&amp;复杂数据类型</p><blockquote><ul><li><p><strong>字符串 数值 布尔类型 null undefined</strong> </p></li><li><p><strong>对象 数组 正则 函数 Map Set</strong></p><p>注：<em>JS中，从变量的存储来看，分为两个地方，栈内存和堆内存。基础数据都存在栈内存</em></p></li></ul></blockquote><h6 id="symbol的妙用"><a href="#symbol的妙用" class="headerlink" title="symbol的妙用"></a>symbol的妙用</h6><blockquote><p>​    <code>symbol.for</code>    看是否存在常量，存在返回此常量，不存在创建此常量    </p><p>​    <code>[symbol.iterator]()</code>创建全新迭代器</p><p><em>当你为对象添加 <code>myObject.toString()</code>方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加 <code>myObject[Symbol.iterator]()</code>方法，就可以用<code>for of</code>遍历这个对象了。</em></p></blockquote><p>###生成器与迭代器的区别</p><blockquote><p>​    生成器包含一个或者多个yeild</p><p>​    迭代器只要是一个iterator就行</p><p><em>问题来了：什么是iterator？名词解释：遍历器，简而言之拥有next方法和done方法的可遍历对象</em></p></blockquote><h3 id="class中的一些禁忌"><a href="#class中的一些禁忌" class="headerlink" title="class中的一些禁忌"></a>class中的一些禁忌</h3><blockquote><ol><li><p>Q:子构造器this应当怎样使用？    </p><p>A:必须先用super，特别在框架中如此使用的时候</p><p>R:创建和初始化是在父构造器中实现的</p></li><li><p>Q：static能在new出来的函数对象中使用吗？</p><p>A：不能</p><p>R：只能定义在class类的函数对象中</p></li></ol></blockquote><h3 id="比较-0和-0"><a href="#比较-0和-0" class="headerlink" title="比较+0和-0"></a>比较+0和-0</h3><blockquote><p>​    ===并不能严格比较+0和-0</p><p>​    应用object.is，<strong>一般情况下用===，性能最高</strong></p><p>​    object.has与object.is方法大致相同，只是不能区分+0和-0，</p><p>​    判断数字用<code>Number.isNaN()</code></p></blockquote><h3 id="数组新增方法"><a href="#数组新增方法" class="headerlink" title="数组新增方法"></a>数组新增方法</h3><blockquote><ol><li><p>Array.from把类数组变为一个真数组</p></li><li><p><code>Array.of(1，2，3，4)</code>把参数1-4变为一个数组</p></li><li><p><code>Array.copyWithin(idx,start,end)</code>从右往左覆盖    ?</p></li><li><p>find/findIndex </p><p>find返回数组中第一个符合条件的元素, findIndex返回索引</p></li><li><p>fill</p><ul><li>数组中的每一个值替换</li><li>范围替换 (val,start,end)</li><li>扩展 [].fill.call({length:3},4);返回<strong>对象</strong>，全是4</li></ul></li><li><p>includes返回boolean值</p></li></ol></blockquote><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><blockquote><p>​    Define:理解为在一个函数内部的函数。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><p>​    自我理解：一个函数a的内部函数b引用上一层函数的变量i，此函数a返回内部函数b，然后此函数a用外部变量接收，即var c = a()相当于c=function b(){};最后执行c();相当于调用b。</p><p>​    作用：1、本来一个局部函数的局部变量只能由他子层函数使用，现在调用到外部来使用</p><p>​            2、隐藏数据，从而保护数据的隐秘性和提高其安全性</p><p>​            3、在内存中维持一个变量，从而实现变量的全局可操作性，例如框架中的cache缓存就必须用到闭包等等。</p></blockquote><h3 id="Vue中使用sort排序进行过滤时出现以下警告"><a href="#Vue中使用sort排序进行过滤时出现以下警告" class="headerlink" title="Vue中使用sort排序进行过滤时出现以下警告"></a>Vue中使用sort排序进行过滤时出现以下警告</h3><blockquote><p>​    array.sort()会计算这个数组本身，会导致filter重新应用，通过复制数组来排序就不会影响原数组重新触发filter过滤器，新数组改变，最后赋值给filter就能达到效果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>how to publish</title>
      <link href="/2018/10/24/new/"/>
      <url>/2018/10/24/new/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> new </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
